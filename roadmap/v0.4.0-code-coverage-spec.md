# Shell-Spec v0.4.0 Specification: Code Coverage Analysis

## Overview

**Version**: 0.4.0
**Feature**: Code Coverage Analysis
**Status**: Planned
**Complexity**: High (Experimental)
**Estimated Lines of Code**: ~250 (new), ~80 (modifications)
**Dependencies**: v0.3.0 (Mocking/Stubbing) should be complete first
**Compatibility**: Bash 4.0+ only (not POSIX-compliant)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Architecture](#2-architecture)
3. [Functional Specification](#3-functional-specification)
4. [Technical Design](#4-technical-design)
5. [Workflows](#5-workflows)
6. [Use Cases](#6-use-cases)
7. [Decision Trees](#7-decision-trees)
8. [Logging & Diagnostics](#8-logging--diagnostics)
9. [Documentation Requirements](#9-documentation-requirements)
10. [Deliverables Checklist](#10-deliverables-checklist)
11. [Testing Strategy](#11-testing-strategy)
12. [Acceptance Criteria](#12-acceptance-criteria)

---

## 1. Executive Summary

### 1.1 Purpose

Add code coverage analysis to shell-spec, enabling developers to measure which lines of their shell scripts are executed during tests. This feature uses Bash's `trap DEBUG` mechanism to intercept line execution and generate coverage reports.

### 1.2 Goals

- Provide `--coverage` flag for line-by-line coverage tracking
- Generate text and HTML coverage reports
- Track per-file and overall coverage percentages
- Integrate coverage data into existing HTML report template
- Support coverage threshold enforcement for CI/CD

### 1.3 Non-Goals

- Branch coverage (if/else path tracking)
- Function-level coverage metrics
- Call count tracking (how many times each line executed)
- Coverage for subshells `$()`, process substitution `<()`, or backgrounded `&` commands
- POSIX shell compatibility (Bash 4.0+ only)

### 1.4 Key Constraints

- Must use file-based data collection (subshell isolation prevents in-memory)
- Performance overhead expected (~2-5x slower)
- Mark as "experimental" feature
- Cannot track lines inside command substitutions or background processes

---

## 2. Architecture

### 2.1 Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              test_runner.sh                                  │
│                                                                             │
│  ┌───────────────┐    ┌────────────────────────────────────────────────┐   │
│  │   Argument    │    │              Test Execution Loop               │   │
│  │   Parser      │    │                                                │   │
│  │               │    │   ┌────────────┐    ┌───────────────────────┐  │   │
│  │  --coverage   │───▶│   │  For each  │───▶│  Subshell Execution   │  │   │
│  │  --cov-report │    │   │  test func │    │                       │  │   │
│  │  --cov-thresh │    │   └────────────┘    │  source coverage.sh   │◀─┼───┼── NEW
│  └───────────────┘    │                     │  setup_coverage()     │  │   │
│                       │                     │  source test_file.sh  │  │   │
│                       │                     │  $test_function       │  │   │
│                       │                     │  flush_coverage()     │◀─┼───┼── NEW
│                       │                     └───────────────────────┘  │   │
│                       │                              │                  │   │
│                       │                              ▼                  │   │
│                       │                     ┌───────────────────────┐  │   │
│                       │                     │  Coverage Data File   │  │   │
│                       │                     │  (temp file per test) │  │   │
│                       │                     └───────────────────────┘  │   │
│                       └────────────────────────────────────────────────┘   │
│                                              │                              │
│                                              ▼                              │
│                       ┌────────────────────────────────────────────────┐   │
│                       │              Coverage Aggregation               │   │
│                       │                                                │   │
│                       │  aggregate_coverage()                          │   │
│                       │  calculate_percentages()                       │   │
│                       │  generate_coverage_report()                    │   │
│                       └────────────────────────────────────────────────┘   │
│                                              │                              │
│                                              ▼                              │
│                       ┌────────────────────────────────────────────────┐   │
│                       │              Output Formatters                  │   │
│                       │                                                │   │
│                       │  ┌──────────────┐  ┌──────────────────────┐   │   │
│                       │  │ Text Report  │  │ HTML Report + Coverage│   │   │
│                       │  └──────────────┘  └──────────────────────┘   │   │
│                       └────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │      src/coverage.sh          │  ◀── NEW FILE
                    │                               │
                    │  Configuration:               │
                    │  • COVERAGE_ENABLED           │
                    │  • COVERAGE_DIR               │
                    │  • COVERAGE_TARGETS[]         │
                    │                               │
                    │  Public API:                  │
                    │  • setup_coverage()           │
                    │  • coverage_tracker()         │
                    │  • flush_coverage()           │
                    │  • aggregate_coverage()       │
                    │  • get_coverage_stats()       │
                    │  • generate_coverage_json()   │
                    │  • generate_coverage_text()   │
                    │                               │
                    │  Internal Helpers:            │
                    │  • _count_executable_lines()  │
                    │  • _is_executable_line()      │
                    │  • _resolve_source_path()     │
                    └───────────────────────────────┘
```

### 2.2 File Structure

```
src/
├── test_runner.sh       # MODIFY: Add --coverage flags, integrate coverage
├── coverage.sh          # NEW: Coverage instrumentation (~250 lines)
├── mocking.sh           # NO CHANGE (from v0.3.0)
├── tap_reporter.sh      # NO CHANGE (from v0.2.0)
├── assertions.sh        # NO CHANGE
└── report_template.html # MODIFY: Add coverage visualization section
```

### 2.3 Coverage Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        Coverage Data Collection Flow                         │
└─────────────────────────────────────────────────────────────────────────────┘

  Test 1 Starts                Test 1 Ends              Test 2 Starts
       │                            │                        │
       ▼                            ▼                        ▼
┌─────────────┐             ┌─────────────┐           ┌─────────────┐
│  Subshell   │             │   Flush     │           │  Subshell   │
│  Created    │             │  Coverage   │           │  Created    │
└──────┬──────┘             └──────┬──────┘           └──────┬──────┘
       │                           │                         │
       ▼                           ▼                         ▼
┌─────────────┐             ┌─────────────┐           ┌─────────────┐
│ trap DEBUG  │             │ Write to    │           │ trap DEBUG  │
│ installed   │             │ temp file   │           │ installed   │
└──────┬──────┘             └──────┬──────┘           └──────┬──────┘
       │                           │                         │
       ▼                           │                         ▼
┌─────────────┐                    │                  ┌─────────────┐
│ Each line   │                    │                  │ Each line   │
│ triggers    │──────────┐         │         ┌────────│ triggers    │
│ trap        │          │         │         │        │ trap        │
└─────────────┘          │         │         │        └─────────────┘
                         ▼         ▼         ▼
                    ┌─────────────────────────────┐
                    │     Coverage Temp Files     │
                    │                             │
                    │  /tmp/cov_$$/test1.cov      │
                    │  /tmp/cov_$$/test2.cov      │
                    │  ...                        │
                    └──────────────┬──────────────┘
                                   │
                                   ▼
                    ┌─────────────────────────────┐
                    │      Aggregation Phase      │
                    │                             │
                    │  • Read all .cov files      │
                    │  • Deduplicate line numbers │
                    │  • Group by source file     │
                    │  • Calculate percentages    │
                    └──────────────┬──────────────┘
                                   │
                                   ▼
                    ┌─────────────────────────────┐
                    │        Final Report         │
                    │                             │
                    │  src/utils.sh: 85% (17/20)  │
                    │  src/main.sh: 72% (36/50)   │
                    │  ─────────────────────────  │
                    │  Total: 76% (53/70)         │
                    └─────────────────────────────┘
```

### 2.4 DEBUG Trap Mechanism

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    How DEBUG Trap Coverage Works                             │
└─────────────────────────────────────────────────────────────────────────────┘

Script being tested (utils.sh):
┌────────────────────────────────────────┐
│  1  #!/bin/bash                        │  ← Not executable (shebang)
│  2  # Utility functions                │  ← Not executable (comment)
│  3                                     │  ← Not executable (blank)
│  4  add_numbers() {                    │  ← Not executable (function def)
│  5      local a=$1                     │  ← EXECUTABLE → DEBUG fires
│  6      local b=$2                     │  ← EXECUTABLE → DEBUG fires
│  7      echo $((a + b))                │  ← EXECUTABLE → DEBUG fires
│  8  }                                  │  ← Not executable (closing brace)
│  9                                     │  ← Not executable (blank)
│ 10  multiply() {                       │  ← Not executable (function def)
│ 11      echo $(($1 * $2))              │  ← EXECUTABLE → DEBUG fires (if called)
│ 12  }                                  │  ← Not executable (closing brace)
└────────────────────────────────────────┘

Test execution:
┌────────────────────────────────────────┐
│  source utils.sh                       │
│  result=$(add_numbers 5 3)             │  ← Calls add_numbers
│  # multiply() never called             │
└────────────────────────────────────────┘

Coverage result:
┌────────────────────────────────────────┐
│  Lines executed: 5, 6, 7               │
│  Lines not executed: 11                │
│  Executable lines: 4 (lines 5,6,7,11)  │
│  Coverage: 3/4 = 75%                   │
└────────────────────────────────────────┘

Trap handler records:
┌────────────────────────────────────────┐
│  /path/to/utils.sh:5                   │
│  /path/to/utils.sh:6                   │
│  /path/to/utils.sh:7                   │
└────────────────────────────────────────┘
```

### 2.5 Subshell Isolation Solution

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   Solving Subshell Data Isolation                            │
└─────────────────────────────────────────────────────────────────────────────┘

Problem: Subshell variables don't propagate to parent

    Parent Shell                    Subshell (test)
    ┌─────────────┐                ┌─────────────────┐
    │ COVERAGE=() │                │ trap DEBUG      │
    │             │ ──(fork)──▶    │ COVERAGE+=(5)   │
    │             │                │ COVERAGE+=(6)   │
    │             │ ◀──(exit)──    │ # data lost!    │
    │ COVERAGE=() │                └─────────────────┘
    └─────────────┘                         ✗

Solution: File-based IPC (Inter-Process Communication)

    Parent Shell                    Subshell (test)
    ┌─────────────┐                ┌─────────────────┐
    │ export COV_ │                │ trap DEBUG      │
    │ FILE=/tmp/  │ ──(fork)──▶    │ echo 5 >> $COV_ │
    │ test1.cov   │                │ echo 6 >> $COV_ │
    │             │ ◀──(exit)──    │ FILE            │
    │ read $COV_  │                └─────────────────┘
    │ FILE        │                         ✓
    └─────────────┘

    /tmp/test1.cov:
    ┌─────────────┐
    │ utils.sh:5  │
    │ utils.sh:6  │
    │ utils.sh:7  │
    └─────────────┘
```

---

## 3. Functional Specification

### 3.1 Command-Line Interface

#### 3.1.1 --coverage

```bash
shell-spec --coverage [test_pattern]
```

**Purpose**: Enable coverage tracking and display text report after tests.

**Output**:
```
Running tests...
Found 5 tests.
Running tests: [====================] 5/5 (100%)

--- Coverage Report ---
Coverage: src/utils.sh
  Lines: 17/20 (85%)
Coverage: src/main.sh
  Lines: 36/50 (72%)
─────────────────────
Total: 53/70 (76%)

--- Test Summary ---
Total tests: 5
Passed: 5
Failed: 0
```

#### 3.1.2 --coverage-report

```bash
shell-spec --coverage --coverage-report coverage.json
```

**Purpose**: Save detailed coverage data to JSON file.

**JSON Output Format**:
```json
{
  "summary": {
    "total_lines": 70,
    "covered_lines": 53,
    "coverage_percent": 75.71
  },
  "files": {
    "src/utils.sh": {
      "total_lines": 20,
      "covered_lines": 17,
      "coverage_percent": 85.0,
      "lines": {
        "5": "covered",
        "6": "covered",
        "7": "covered",
        "11": "uncovered"
      }
    },
    "src/main.sh": {
      "total_lines": 50,
      "covered_lines": 36,
      "coverage_percent": 72.0,
      "lines": { ... }
    }
  }
}
```

#### 3.1.3 --coverage-threshold

```bash
shell-spec --coverage --coverage-threshold 80
```

**Purpose**: Fail test run if coverage is below threshold.

**Behavior**:
- If overall coverage < threshold: exit with code 1
- Print warning message: `Coverage 76% is below threshold 80%`

#### 3.1.4 Combined with HTML Report

```bash
shell-spec --coverage --html report.html
```

**Purpose**: Include coverage visualization in HTML report.

### 3.2 Coverage Tracking Scope

#### 3.2.1 What IS Tracked

| Element | Tracked | Notes |
|---------|---------|-------|
| Simple commands | ✓ | `echo "hello"`, `ls -la` |
| Variable assignments | ✓ | `x=5`, `local y=10` |
| Function bodies | ✓ | Lines inside functions when called |
| Conditionals | ✓ | The `if`/`then`/`else` lines themselves |
| Loops | ✓ | `for`/`while`/`until` header lines |
| Case statements | ✓ | `case` and pattern lines |
| Pipelines | ✓ | First command in pipeline |

#### 3.2.2 What is NOT Tracked

| Element | Reason |
|---------|--------|
| Shebang line (`#!/bin/bash`) | Not executable |
| Comments | Not executable |
| Blank lines | Not executable |
| Function definition lines | Only bodies are tracked |
| Closing braces/`esac`/`done`/`fi` | Syntax, not execution |
| Command substitutions `$(...)` | Runs in subshell |
| Process substitution `<(...)` | Runs in separate process |
| Backgrounded commands `cmd &` | Runs asynchronously |
| Here-documents content | Treated as string data |

### 3.3 Coverage Calculation

#### 3.3.1 Executable Line Detection

A line is considered "executable" if it:
1. Is not blank (after trimming whitespace)
2. Does not start with `#` (comment)
3. Is not a function definition header (`function_name() {`)
4. Is not a control structure closing (`}`, `fi`, `done`, `esac`)
5. Is not a shebang (`#!`)

#### 3.3.2 Coverage Percentage Formula

```
coverage_percent = (covered_lines / executable_lines) * 100
```

**Example**:
```
Script: 50 total lines
  - 10 blank lines
  - 8 comment lines
  - 2 function definition lines
  - 30 executable lines
  - 24 executed during tests

Coverage = 24/30 = 80%
```

---

## 4. Technical Design

### 4.1 New File: `src/coverage.sh`

```bash
#!/bin/bash
# =============================================================================
# coverage.sh - Code Coverage Analysis Library for shell-spec
# =============================================================================
#
# Part of shell-spec testing framework
# https://github.com/southpawriter02/shell-spec
#
# This module provides line-by-line code coverage tracking for shell scripts.
# It uses Bash's DEBUG trap to intercept each line execution and records
# coverage data to temporary files for aggregation.
#
# IMPORTANT: This feature is EXPERIMENTAL and has known limitations:
#   - Bash 4.0+ only (not POSIX compatible)
#   - Does not track lines inside $() or <() constructs
#   - Does not track backgrounded commands (&)
#   - Performance overhead of approximately 2-5x
#
# Usage:
#   source coverage.sh
#   setup_coverage "/path/to/script.sh"
#   # ... run tests ...
#   flush_coverage
#   aggregate_coverage
#   generate_coverage_text
#
# =============================================================================

# === Configuration ===
declare COVERAGE_ENABLED=false
declare COVERAGE_DIR=""
declare COVERAGE_FILE=""
declare -a COVERAGE_TARGETS=()
declare -A COVERAGE_DATA=()
declare COVERAGE_BUFFER=""
declare COVERAGE_BUFFER_SIZE=0
declare -r COVERAGE_BUFFER_FLUSH_SIZE=50

# === Setup Functions ===

# setup_coverage: Initialize coverage tracking for a test
#
# Creates temporary directory and file for coverage data collection.
# Sets up the DEBUG trap to intercept line execution.
#
# Arguments:
#   $1 - script_file : Path to script being tested (optional)
#
# Environment:
#   COVERAGE_DIR - Set to temp directory path
#   COVERAGE_FILE - Set to current coverage data file
#
# Example:
#   setup_coverage "/path/to/utils.sh"
#
setup_coverage() {
    local script_file="${1:-}"

    COVERAGE_ENABLED=true

    # Create temp directory if not exists
    if [[ -z "$COVERAGE_DIR" ]]; then
        COVERAGE_DIR=$(mktemp -d -t "shellspec_coverage_XXXXXX")
    fi

    # Create unique coverage file for this test
    local test_id="${FUNCNAME[2]:-test}_$$_$(date +%s%N)"
    COVERAGE_FILE="$COVERAGE_DIR/${test_id}.cov"

    # Add target script to tracking list
    if [[ -n "$script_file" ]]; then
        COVERAGE_TARGETS+=("$(cd "$(dirname "$script_file")" && pwd)/$(basename "$script_file")")
    fi

    # Reset buffer
    COVERAGE_BUFFER=""
    COVERAGE_BUFFER_SIZE=0

    # Install DEBUG trap
    # Use set -T to propagate trap to functions
    set -T
    trap '_coverage_tracker' DEBUG
}

# _coverage_tracker: DEBUG trap handler (internal)
#
# Called before each command execution. Records the source file
# and line number to the coverage buffer.
#
# Uses BASH_SOURCE and LINENO to identify the executed line.
# Buffers writes to minimize I/O overhead.
#
_coverage_tracker() {
    # Skip if coverage not enabled
    [[ "$COVERAGE_ENABLED" != "true" ]] && return

    # Get source file (caller's context)
    local source_file="${BASH_SOURCE[1]:-}"
    local line_number="${BASH_LINENO[0]:-}"

    # Skip if no source info
    [[ -z "$source_file" || -z "$line_number" ]] && return

    # Skip shell-spec internal files
    case "$source_file" in
        */coverage.sh|*/assertions.sh|*/mocking.sh|*/tap_reporter.sh|*/test_runner.sh)
            return
            ;;
    esac

    # Resolve to absolute path
    if [[ "$source_file" != /* ]]; then
        source_file="$(cd "$(dirname "$source_file")" 2>/dev/null && pwd)/$(basename "$source_file")"
    fi

    # Add to buffer
    COVERAGE_BUFFER+="${source_file}:${line_number}"$'\n'
    ((COVERAGE_BUFFER_SIZE++))

    # Flush if buffer is full
    if ((COVERAGE_BUFFER_SIZE >= COVERAGE_BUFFER_FLUSH_SIZE)); then
        _flush_buffer
    fi
}

# _flush_buffer: Write buffered coverage data to file (internal)
#
_flush_buffer() {
    if [[ -n "$COVERAGE_BUFFER" && -n "$COVERAGE_FILE" ]]; then
        printf "%s" "$COVERAGE_BUFFER" >> "$COVERAGE_FILE"
        COVERAGE_BUFFER=""
        COVERAGE_BUFFER_SIZE=0
    fi
}

# flush_coverage: Finalize coverage data for current test
#
# Writes any remaining buffered data and removes the DEBUG trap.
# Should be called at the end of each test.
#
# Example:
#   flush_coverage
#
flush_coverage() {
    # Flush remaining buffer
    _flush_buffer

    # Remove trap
    trap - DEBUG
    set +T
}

# === Aggregation Functions ===

# aggregate_coverage: Combine all coverage data from temp files
#
# Reads all .cov files in COVERAGE_DIR, deduplicates entries,
# and builds the COVERAGE_DATA associative array.
#
# Output:
#   COVERAGE_DATA["file:line"] = 1 (for each covered line)
#
# Example:
#   aggregate_coverage
#   echo "Covered files: ${!COVERAGE_DATA[@]}"
#
aggregate_coverage() {
    COVERAGE_DATA=()

    [[ -z "$COVERAGE_DIR" || ! -d "$COVERAGE_DIR" ]] && return

    # Read all coverage files
    local cov_file
    for cov_file in "$COVERAGE_DIR"/*.cov; do
        [[ -f "$cov_file" ]] || continue

        while IFS= read -r line; do
            [[ -n "$line" ]] && COVERAGE_DATA["$line"]=1
        done < "$cov_file"
    done
}

# get_coverage_stats: Calculate coverage statistics
#
# Arguments:
#   $1 - script_file : Path to script to analyze
#
# Output (to stdout):
#   Three space-separated values: executable_lines covered_lines percent
#
# Example:
#   stats=$(get_coverage_stats "src/utils.sh")
#   read total covered percent <<< "$stats"
#
get_coverage_stats() {
    local script_file="$1"
    local executable_lines=0
    local covered_lines=0
    local line_number=0

    # Resolve absolute path
    if [[ "$script_file" != /* ]]; then
        script_file="$(cd "$(dirname "$script_file")" 2>/dev/null && pwd)/$(basename "$script_file")"
    fi

    # Read script and count lines
    while IFS= read -r line || [[ -n "$line" ]]; do
        ((line_number++))

        if _is_executable_line "$line"; then
            ((executable_lines++))

            if [[ -n "${COVERAGE_DATA["${script_file}:${line_number}"]:-}" ]]; then
                ((covered_lines++))
            fi
        fi
    done < "$script_file"

    # Calculate percentage
    local percent=0
    if ((executable_lines > 0)); then
        percent=$(awk "BEGIN {printf \"%.1f\", ($covered_lines / $executable_lines) * 100}")
    fi

    echo "$executable_lines $covered_lines $percent"
}

# _is_executable_line: Check if a line is executable (internal)
#
# Arguments:
#   $1 - line content
#
# Returns:
#   0 if executable, 1 if not
#
_is_executable_line() {
    local line="$1"

    # Trim whitespace
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    # Empty line
    [[ -z "$line" ]] && return 1

    # Comment (but not shebang)
    [[ "$line" == "#"* && "$line" != "#!"* ]] && return 1

    # Shebang
    [[ "$line" == "#!"* ]] && return 1

    # Function definition (ends with { or ()
    [[ "$line" =~ ^[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*\(\)[[:space:]]*\{?$ ]] && return 1
    [[ "$line" =~ ^function[[:space:]]+[a-zA-Z_][a-zA-Z0-9_]*[[:space:]]*\{?$ ]] && return 1

    # Closing braces and keywords
    [[ "$line" == "}" ]] && return 1
    [[ "$line" == "fi" ]] && return 1
    [[ "$line" == "done" ]] && return 1
    [[ "$line" == "esac" ]] && return 1
    [[ "$line" == "then" ]] && return 1
    [[ "$line" == "else" ]] && return 1
    [[ "$line" == "elif"* ]] && return 1
    [[ "$line" == "do" ]] && return 1

    return 0
}

# === Report Generation ===

# generate_coverage_text: Output text coverage report
#
# Prints a formatted coverage report to stdout.
#
# Example:
#   generate_coverage_text
#
generate_coverage_text() {
    echo ""
    echo "--- Coverage Report ---"

    local total_executable=0
    local total_covered=0

    # Get unique files from coverage data
    local -A files=()
    for key in "${!COVERAGE_DATA[@]}"; do
        local file="${key%:*}"
        files["$file"]=1
    done

    # Also include target files that may have 0% coverage
    for target in "${COVERAGE_TARGETS[@]}"; do
        files["$target"]=1
    done

    # Report per file
    for file in "${!files[@]}"; do
        [[ -f "$file" ]] || continue

        local stats
        stats=$(get_coverage_stats "$file")
        read -r executable covered percent <<< "$stats"

        ((total_executable += executable))
        ((total_covered += covered))

        # Shorten path for display
        local display_file="$file"
        if [[ "$file" == "$PWD"/* ]]; then
            display_file=".${file#$PWD}"
        fi

        echo "Coverage: $display_file"
        echo "  Lines: ${covered}/${executable} (${percent}%)"
    done

    # Total
    local total_percent=0
    if ((total_executable > 0)); then
        total_percent=$(awk "BEGIN {printf \"%.1f\", ($total_covered / $total_executable) * 100}")
    fi

    echo "─────────────────────"
    echo "Total: ${total_covered}/${total_executable} (${total_percent}%)"
}

# generate_coverage_json: Output JSON coverage report
#
# Arguments:
#   $1 - output_file : Path to write JSON (optional, defaults to stdout)
#
# Example:
#   generate_coverage_json "coverage.json"
#
generate_coverage_json() {
    local output_file="${1:-/dev/stdout}"

    local total_executable=0
    local total_covered=0

    # Build file list
    local -A files=()
    for key in "${!COVERAGE_DATA[@]}"; do
        local file="${key%:*}"
        files["$file"]=1
    done
    for target in "${COVERAGE_TARGETS[@]}"; do
        files["$target"]=1
    done

    # Start JSON
    local json='{'
    json+='"files": {'

    local first_file=true
    for file in "${!files[@]}"; do
        [[ -f "$file" ]] || continue

        $first_file || json+=','
        first_file=false

        local stats
        stats=$(get_coverage_stats "$file")
        read -r executable covered percent <<< "$stats"

        ((total_executable += executable))
        ((total_covered += covered))

        json+="\"$file\": {"
        json+="\"total_lines\": $executable,"
        json+="\"covered_lines\": $covered,"
        json+="\"coverage_percent\": $percent,"
        json+='"lines": {'

        # Per-line coverage
        local line_number=0
        local first_line=true
        while IFS= read -r line || [[ -n "$line" ]]; do
            ((line_number++))

            if _is_executable_line "$line"; then
                $first_line || json+=','
                first_line=false

                if [[ -n "${COVERAGE_DATA["${file}:${line_number}"]:-}" ]]; then
                    json+="\"$line_number\": \"covered\""
                else
                    json+="\"$line_number\": \"uncovered\""
                fi
            fi
        done < "$file"

        json+='}}'
    done

    json+='},'

    # Summary
    local total_percent=0
    if ((total_executable > 0)); then
        total_percent=$(awk "BEGIN {printf \"%.2f\", ($total_covered / $total_executable) * 100}")
    fi

    json+='"summary": {'
    json+="\"total_lines\": $total_executable,"
    json+="\"covered_lines\": $total_covered,"
    json+="\"coverage_percent\": $total_percent"
    json+='}}'

    echo "$json" > "$output_file"
}

# check_coverage_threshold: Verify coverage meets minimum
#
# Arguments:
#   $1 - threshold : Minimum coverage percentage (0-100)
#
# Returns:
#   0 if coverage >= threshold, 1 if below
#
# Example:
#   if ! check_coverage_threshold 80; then
#       echo "Coverage below 80%!"
#       exit 1
#   fi
#
check_coverage_threshold() {
    local threshold="$1"

    local total_executable=0
    local total_covered=0

    local -A files=()
    for key in "${!COVERAGE_DATA[@]}"; do
        local file="${key%:*}"
        files["$file"]=1
    done

    for file in "${!files[@]}"; do
        [[ -f "$file" ]] || continue

        local stats
        stats=$(get_coverage_stats "$file")
        read -r executable covered percent <<< "$stats"

        ((total_executable += executable))
        ((total_covered += covered))
    done

    local total_percent=0
    if ((total_executable > 0)); then
        total_percent=$(awk "BEGIN {printf \"%.0f\", ($total_covered / $total_executable) * 100}")
    fi

    if ((total_percent < threshold)); then
        echo "Coverage ${total_percent}% is below threshold ${threshold}%" >&2
        return 1
    fi

    return 0
}

# cleanup_coverage: Remove temporary coverage files
#
# Should be called at the end of the test run.
#
# Example:
#   cleanup_coverage
#
cleanup_coverage() {
    if [[ -n "$COVERAGE_DIR" && -d "$COVERAGE_DIR" ]]; then
        rm -rf "$COVERAGE_DIR"
    fi
    COVERAGE_DIR=""
    COVERAGE_FILE=""
    COVERAGE_DATA=()
    COVERAGE_TARGETS=()
}
```

### 4.2 Modifications to `src/test_runner.sh`

#### 4.2.1 Add Coverage Arguments (after line 52)

```bash
# Add after existing argument parsing
COVERAGE_ENABLED=false
COVERAGE_REPORT_FILE=""
COVERAGE_THRESHOLD=""

# In argument parsing loop:
    --coverage)
      COVERAGE_ENABLED=true
      shift
      ;;
    --coverage-report)
      COVERAGE_REPORT_FILE="$2"
      shift 2
      ;;
    --coverage-threshold)
      COVERAGE_THRESHOLD="$2"
      shift 2
      ;;
```

#### 4.2.2 Source Coverage Library (after line 31)

```bash
source "$SCRIPT_DIR/assertions.sh"
source "$SCRIPT_DIR/mocking.sh"
if $COVERAGE_ENABLED; then
    source "$SCRIPT_DIR/coverage.sh"
fi
```

#### 4.2.3 Modify Test Execution (lines 155-161)

```bash
# Current:
output=$(
  (
    source "$SCRIPT_DIR/assertions.sh"
    source "$SCRIPT_DIR/mocking.sh"
    source "$file"
    $func
    unmock_all
  ) 2>&1
)

# Modified:
output=$(
  (
    source "$SCRIPT_DIR/assertions.sh"
    source "$SCRIPT_DIR/mocking.sh"

    # NEW: Coverage setup
    if [[ "$COVERAGE_ENABLED" == "true" ]]; then
        source "$SCRIPT_DIR/coverage.sh"
        export COVERAGE_DIR
        setup_coverage "$file"
    fi

    source "$file"
    $func
    unmock_all

    # NEW: Flush coverage before exit
    if [[ "$COVERAGE_ENABLED" == "true" ]]; then
        flush_coverage
    fi
  ) 2>&1
)
```

#### 4.2.4 Add Coverage Report Generation (end of run_all_tests)

```bash
# At end of run_all_tests function, before return:

if $COVERAGE_ENABLED; then
    # Aggregate all coverage data
    aggregate_coverage

    # Generate text report
    generate_coverage_text

    # Generate JSON report if requested
    if [[ -n "$COVERAGE_REPORT_FILE" ]]; then
        generate_coverage_json "$COVERAGE_REPORT_FILE"
        echo "Coverage report saved to $COVERAGE_REPORT_FILE"
    fi

    # Check threshold if specified
    if [[ -n "$COVERAGE_THRESHOLD" ]]; then
        if ! check_coverage_threshold "$COVERAGE_THRESHOLD"; then
            tests_failed=1  # Fail the test run
        fi
    fi

    # Cleanup
    cleanup_coverage
fi
```

### 4.3 HTML Report Template Enhancement

Add coverage section to `src/report_template.html`:

#### 4.3.1 Add Coverage Summary Card (after line 156)

```html
<!-- Add after Failed card -->
<div class="card" id="coverage-card" style="display: none;">
    <div class="card-title">Coverage</div>
    <div class="card-value" id="coverage-percent">0%</div>
</div>
```

#### 4.3.2 Add Coverage Details Section (after results table, line 175)

```html
<!-- Coverage Details Section -->
<div id="coverage-section" style="display: none; margin-top: 30px;">
    <h2>Code Coverage</h2>

    <table class="results-table" id="coverage-table">
        <thead>
            <tr>
                <th>File</th>
                <th>Lines</th>
                <th>Coverage</th>
                <th>Progress</th>
            </tr>
        </thead>
        <tbody id="coverage-body">
            <!-- Rows injected by JavaScript -->
        </tbody>
    </table>

    <!-- Line-by-line view (collapsible) -->
    <div id="coverage-details" style="margin-top: 20px;">
        <!-- Expandable file coverage details -->
    </div>
</div>

<style>
    .coverage-bar {
        background-color: #333;
        border-radius: 4px;
        height: 20px;
        overflow: hidden;
    }

    .coverage-bar-fill {
        height: 100%;
        transition: width 0.3s;
    }

    .coverage-good { background-color: var(--success-color); }
    .coverage-medium { background-color: #ff9800; }
    .coverage-poor { background-color: var(--fail-color); }

    .line-covered { background-color: rgba(76, 175, 80, 0.2); }
    .line-uncovered { background-color: rgba(244, 67, 54, 0.2); }
    .line-number {
        color: #888;
        padding-right: 10px;
        text-align: right;
        user-select: none;
    }

    .source-code {
        font-family: monospace;
        font-size: 12px;
        background-color: #1e1e1e;
        padding: 10px;
        border-radius: 4px;
        overflow-x: auto;
        margin-top: 10px;
    }

    .source-line {
        display: flex;
        padding: 2px 0;
    }
</style>
```

#### 4.3.3 Add Coverage Rendering JavaScript (in script section)

```javascript
function renderCoverage(data) {
    if (!data.coverage) return;

    // Show coverage UI
    document.getElementById('coverage-card').style.display = 'block';
    document.getElementById('coverage-section').style.display = 'block';

    // Update summary
    document.getElementById('coverage-percent').textContent =
        data.coverage.summary.coverage_percent.toFixed(1) + '%';

    // Render file table
    const tbody = document.getElementById('coverage-body');
    tbody.innerHTML = '';

    for (const [file, fileData] of Object.entries(data.coverage.files)) {
        const tr = document.createElement('tr');
        const percent = fileData.coverage_percent;
        const coverageClass = percent >= 80 ? 'coverage-good' :
                              percent >= 50 ? 'coverage-medium' : 'coverage-poor';

        tr.innerHTML = `
            <td>${escapeHtml(file)}</td>
            <td>${fileData.covered_lines}/${fileData.total_lines}</td>
            <td>${percent.toFixed(1)}%</td>
            <td>
                <div class="coverage-bar">
                    <div class="coverage-bar-fill ${coverageClass}"
                         style="width: ${percent}%"></div>
                </div>
            </td>
        `;
        tbody.appendChild(tr);
    }
}

// Call in renderDashboard
if (data.coverage) {
    renderCoverage(data);
}
```

---

## 5. Workflows

### 5.1 Coverage Collection Workflow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   User runs: shell-spec --coverage tests/                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 1. Parse arguments                                                           │
│    • COVERAGE_ENABLED=true                                                  │
│    • Source coverage.sh                                                     │
│    • Create COVERAGE_DIR temp directory                                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 2. For each test function                                                    │
│    • Create subshell                                                        │
│    • Call setup_coverage(test_file)                                         │
│    • Install DEBUG trap                                                     │
│    • Source test file                                                       │
│    • Execute test function                                                  │
│    • Call flush_coverage()                                                  │
│    • Exit subshell (data persisted to COVERAGE_DIR)                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 3. After all tests complete                                                  │
│    • Call aggregate_coverage()                                              │
│    • Read all .cov files from COVERAGE_DIR                                  │
│    • Deduplicate file:line entries                                          │
│    • Build COVERAGE_DATA map                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 4. Generate reports                                                          │
│    • Call generate_coverage_text() for console output                       │
│    • Call generate_coverage_json() if --coverage-report specified           │
│    • Call check_coverage_threshold() if --coverage-threshold specified      │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 5. Cleanup                                                                   │
│    • Call cleanup_coverage()                                                │
│    • Remove COVERAGE_DIR and all temp files                                 │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 DEBUG Trap Execution Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              DEBUG trap fires before each command                            │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 1. Check if coverage enabled                                                 │
│    • COVERAGE_ENABLED != true → return immediately                          │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 2. Get source context                                                        │
│    • source_file = BASH_SOURCE[1]                                           │
│    • line_number = BASH_LINENO[0]                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 3. Filter internal files                                                     │
│    • Skip */coverage.sh, */assertions.sh, */mocking.sh, etc.               │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 4. Resolve absolute path                                                     │
│    • Convert relative paths to absolute                                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 5. Buffer coverage entry                                                     │
│    • COVERAGE_BUFFER += "${file}:${line}\n"                                 │
│    • Increment COVERAGE_BUFFER_SIZE                                         │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 6. Check buffer threshold                                                    │
│    • If BUFFER_SIZE >= 50 → flush to file                                   │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.3 Coverage Aggregation Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        aggregate_coverage() called                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 1. Initialize COVERAGE_DATA associative array                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 2. For each .cov file in COVERAGE_DIR:                                       │
│                                                                             │
│    /tmp/cov_12345/test_add_123.cov:                                         │
│    ┌────────────────────────────┐                                           │
│    │ /path/utils.sh:5           │                                           │
│    │ /path/utils.sh:6           │                                           │
│    │ /path/utils.sh:7           │                                           │
│    └────────────────────────────┘                                           │
│                                                                             │
│    /tmp/cov_12345/test_mul_124.cov:                                         │
│    ┌────────────────────────────┐                                           │
│    │ /path/utils.sh:5           │  ← Duplicate                              │
│    │ /path/utils.sh:11          │  ← New                                    │
│    └────────────────────────────┘                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 3. Add each entry to COVERAGE_DATA (deduplicates automatically)              │
│                                                                             │
│    COVERAGE_DATA = {                                                        │
│        "/path/utils.sh:5": 1,                                               │
│        "/path/utils.sh:6": 1,                                               │
│        "/path/utils.sh:7": 1,                                               │
│        "/path/utils.sh:11": 1                                               │
│    }                                                                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 4. Ready for get_coverage_stats() and report generation                      │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 6. Use Cases

### 6.1 UC-01: Basic Coverage Report

**Actor**: Developer wanting to see test coverage
**Goal**: View coverage statistics for a script

```bash
# utils.sh
add() {
    echo $(($1 + $2))
}

subtract() {
    echo $(($1 - $2))
}

# utils_test.sh
test_add() {
    result=$(add 5 3)
    assert_equals "8" "$result"
}
# Note: subtract() is never tested

# Run tests with coverage
$ shell-spec --coverage tests/

Running tests: [====================] 1/1 (100%)

--- Coverage Report ---
Coverage: ./utils.sh
  Lines: 1/2 (50%)
─────────────────────
Total: 1/2 (50%)

--- Test Summary ---
Total tests: 1
Passed: 1
Failed: 0
```

### 6.2 UC-02: Coverage Threshold Enforcement

**Actor**: CI/CD pipeline
**Goal**: Fail build if coverage drops below minimum

```bash
# .github/workflows/test.yml
- name: Run tests with coverage
  run: |
    shell-spec --coverage --coverage-threshold 80 tests/

# If coverage is 76%:
$ shell-spec --coverage --coverage-threshold 80 tests/
...
Coverage 76% is below threshold 80%
$ echo $?
1
```

### 6.3 UC-03: JSON Coverage Report

**Actor**: Coverage visualization tool
**Goal**: Generate machine-readable coverage data

```bash
$ shell-spec --coverage --coverage-report coverage.json tests/

$ cat coverage.json
{
  "files": {
    "./src/utils.sh": {
      "total_lines": 10,
      "covered_lines": 8,
      "coverage_percent": 80.0,
      "lines": {
        "5": "covered",
        "6": "covered",
        "7": "covered",
        "11": "uncovered",
        "12": "uncovered"
      }
    }
  },
  "summary": {
    "total_lines": 10,
    "covered_lines": 8,
    "coverage_percent": 80.0
  }
}
```

### 6.4 UC-04: HTML Report with Coverage

**Actor**: Developer reviewing test results
**Goal**: Visual coverage display in HTML report

```bash
$ shell-spec --coverage --html report.html tests/

# Opens report.html in browser:
# - Summary cards show: Total 5 | Passed 5 | Failed 0 | Coverage 85%
# - Coverage table shows per-file breakdown
# - Expandable source view shows line-by-line coverage
```

### 6.5 UC-05: Multiple Test Files

**Actor**: Developer with comprehensive test suite
**Goal**: Aggregate coverage across all tests

```bash
# Structure:
# src/
#   math.sh      (10 executable lines)
#   string.sh    (15 executable lines)
# tests/
#   math_test.sh       (tests math.sh)
#   string_test.sh     (tests string.sh)
#   integration_test.sh (tests both)

$ shell-spec --coverage tests/

--- Coverage Report ---
Coverage: ./src/math.sh
  Lines: 8/10 (80%)
Coverage: ./src/string.sh
  Lines: 12/15 (80%)
─────────────────────
Total: 20/25 (80%)
```

### 6.6 UC-06: Identifying Untested Code

**Actor**: Developer improving test coverage
**Goal**: Find which lines need tests

```bash
$ shell-spec --coverage --coverage-report cov.json tests/
$ jq '.files["./src/utils.sh"].lines | to_entries | .[] | select(.value == "uncovered")' cov.json

{"key": "15", "value": "uncovered"}
{"key": "16", "value": "uncovered"}
{"key": "23", "value": "uncovered"}

# Developer can now write tests for lines 15, 16, and 23
```

---

## 7. Decision Trees

### 7.1 Coverage Enable Decision Flow

```
                    ┌─────────────────────────────┐
                    │  shell-spec invoked with    │
                    │  --coverage flag?           │
                    └─────────────┬───────────────┘
                                  │
                    ┌─────────────┴─────────────┐
                    │ No                        │ Yes
                    ▼                           ▼
          ┌─────────────────┐         ┌─────────────────┐
          │ Run tests       │         │ Check bash      │
          │ without         │         │ version >= 4.0  │
          │ coverage        │         └────────┬────────┘
          └─────────────────┘                  │
                                  ┌────────────┴────────────┐
                                  │ No                      │ Yes
                                  ▼                         ▼
                        ┌─────────────────┐       ┌─────────────────┐
                        │ Error: Coverage │       │ Source          │
                        │ requires Bash   │       │ coverage.sh     │
                        │ 4.0+            │       │                 │
                        │ exit 1          │       │ COVERAGE_ENABLED│
                        └─────────────────┘       │ = true          │
                                                  └─────────────────┘
```

### 7.2 Line Executability Decision Flow

```
                    ┌─────────────────────────────┐
                    │  _is_executable_line()      │
                    │  receives line content      │
                    └─────────────┬───────────────┘
                                  │
                                  ▼
                    ┌─────────────────────────────┐
                    │  Trim whitespace            │
                    └─────────────┬───────────────┘
                                  │
                                  ▼
                    ┌─────────────────────────────┐
                    │  Is line empty?             │
                    └─────────────┬───────────────┘
                                  │
                    ┌─────────────┴─────────────┐
                    │ Yes                       │ No
                    ▼                           ▼
          ┌─────────────────┐         ┌─────────────────┐
          │ Return 1        │         │ Starts with #   │
          │ (not executable)│         │ (but not #!)?   │
          └─────────────────┘         └────────┬────────┘
                                               │
                                  ┌────────────┴────────────┐
                                  │ Yes                     │ No
                                  ▼                         ▼
                        ┌─────────────────┐       ┌─────────────────┐
                        │ Return 1        │       │ Is function     │
                        │ (comment)       │       │ definition?     │
                        └─────────────────┘       └────────┬────────┘
                                                           │
                                              ┌────────────┴────────────┐
                                              │ Yes                     │ No
                                              ▼                         ▼
                                    ┌─────────────────┐       ┌─────────────────┐
                                    │ Return 1        │       │ Is closing      │
                                    │ (func def)      │       │ keyword?        │
                                    └─────────────────┘       │ (}, fi, done,   │
                                                              │  esac, then,    │
                                                              │  else, do)      │
                                                              └────────┬────────┘
                                                                       │
                                                          ┌────────────┴────────────┐
                                                          │ Yes                     │ No
                                                          ▼                         ▼
                                                ┌─────────────────┐       ┌─────────────────┐
                                                │ Return 1        │       │ Return 0        │
                                                │ (syntax only)   │       │ (EXECUTABLE!)   │
                                                └─────────────────┘       └─────────────────┘
```

### 7.3 Coverage Threshold Check Flow

```
                    ┌─────────────────────────────┐
                    │  --coverage-threshold N     │
                    │  specified?                 │
                    └─────────────┬───────────────┘
                                  │
                    ┌─────────────┴─────────────┐
                    │ No                        │ Yes
                    ▼                           ▼
          ┌─────────────────┐         ┌─────────────────┐
          │ Skip threshold  │         │ Calculate       │
          │ check           │         │ total_percent   │
          └─────────────────┘         └────────┬────────┘
                                               │
                                               ▼
                                    ┌─────────────────────────┐
                                    │ total_percent >= N?     │
                                    └─────────────┬───────────┘
                                                  │
                                    ┌─────────────┴─────────────┐
                                    │ No                        │ Yes
                                    ▼                           ▼
                          ┌─────────────────┐         ┌─────────────────┐
                          │ Print warning   │         │ Continue        │
                          │ "Coverage X%    │         │ normally        │
                          │ below threshold │         │                 │
                          │ N%"             │         │ exit 0          │
                          │                 │         └─────────────────┘
                          │ tests_failed=1  │
                          │ exit 1          │
                          └─────────────────┘
```

---

## 8. Logging & Diagnostics

### 8.1 Coverage-Specific Messages

| Condition | Message | Destination |
|-----------|---------|-------------|
| Coverage enabled | (no message, silent) | - |
| Below threshold | `Coverage X% is below threshold Y%` | stderr |
| Report saved | `Coverage report saved to FILE` | stdout |
| No coverage data | `No coverage data collected` | stderr |
| Bash version error | `Error: Coverage requires Bash 4.0+` | stderr |

### 8.2 Verbose Mode Output

When `--verbose` is combined with `--coverage`:

```
$ shell-spec --coverage --verbose tests/

[coverage] Coverage tracking enabled
[coverage] COVERAGE_DIR=/tmp/shellspec_coverage_abc123
[coverage] Running test: test_add in tests/math_test.sh
[coverage] DEBUG trap installed
[coverage] Collected 15 line executions
[coverage] Flushed to /tmp/shellspec_coverage_abc123/test_add_12345.cov
...
[coverage] Aggregating 3 coverage files
[coverage] Found 2 unique source files
[coverage] Total: 45 covered lines, 52 executable lines
```

### 8.3 Debug Environment Variable

```bash
# Enable coverage debug output
SHELL_SPEC_COVERAGE_DEBUG=1 shell-spec --coverage tests/

# Shows:
# [cov-debug] Trap fired: /path/utils.sh:5
# [cov-debug] Trap fired: /path/utils.sh:6
# [cov-debug] Buffer flush: 50 entries written
```

---

## 9. Documentation Requirements

### 9.1 Inline Documentation

#### 9.1.1 File Header

```bash
#!/bin/bash
# =============================================================================
# coverage.sh - Code Coverage Analysis Library for shell-spec
# =============================================================================
#
# Part of shell-spec testing framework
# https://github.com/southpawriter02/shell-spec
#
# This module provides line-by-line code coverage tracking for shell scripts.
# It uses Bash's DEBUG trap to intercept each line execution and records
# coverage data to temporary files for aggregation.
#
# IMPORTANT: This feature is EXPERIMENTAL and has known limitations:
#   - Bash 4.0+ only (not POSIX compatible)
#   - Does not track lines inside $() or <() constructs
#   - Does not track backgrounded commands (&)
#   - Performance overhead of approximately 2-5x
#
# Usage:
#   shell-spec --coverage tests/
#   shell-spec --coverage --coverage-threshold 80 tests/
#   shell-spec --coverage --coverage-report coverage.json tests/
#
# =============================================================================
```

### 9.2 README.md Updates

```markdown
## Code Coverage (Experimental)

shell-spec can track which lines of your scripts are executed during tests.

> **Note**: Coverage is an experimental feature requiring Bash 4.0+.

### Basic Usage

```bash
shell-spec --coverage tests/
```

### Coverage Threshold

Fail if coverage drops below a minimum:

```bash
shell-spec --coverage --coverage-threshold 80 tests/
```

### JSON Report

Generate machine-readable coverage data:

```bash
shell-spec --coverage --coverage-report coverage.json tests/
```

### HTML Report with Coverage

Include coverage visualization in HTML report:

```bash
shell-spec --coverage --html report.html tests/
```

### Known Limitations

- **Bash 4.0+ only**: Not compatible with POSIX sh or older Bash versions
- **Subshell blind spots**: Lines inside `$()` or `<()` are not tracked
- **Background processes**: Commands run with `&` are not tracked
- **Performance**: Expect 2-5x slower test execution
- **Line coverage only**: Branch and function coverage not supported
```

### 9.3 Changelog Entry

```markdown
## [0.4.0] - YYYY-MM-DD

### Added
- Code coverage analysis (`src/coverage.sh`) [EXPERIMENTAL]
- `--coverage` flag to enable line-by-line coverage tracking
- `--coverage-report FILE` to save JSON coverage report
- `--coverage-threshold N` to enforce minimum coverage percentage
- Coverage visualization in HTML reports
- Per-file and overall coverage statistics

### Changed
- test_runner.sh integrates coverage tracking in test execution loop
- report_template.html includes coverage summary card and details table

### Notes
- Coverage requires Bash 4.0+ (not POSIX compatible)
- Known limitations: subshells, process substitution, background jobs not tracked
- Performance overhead ~2-5x when coverage enabled
```

---

## 10. Deliverables Checklist

### 10.1 Code Deliverables

- [ ] **src/coverage.sh** (new file, ~250 lines)
  - [ ] `COVERAGE_ENABLED` configuration variable
  - [ ] `COVERAGE_DIR` temp directory management
  - [ ] `COVERAGE_FILE` per-test file path
  - [ ] `COVERAGE_TARGETS[]` tracked scripts array
  - [ ] `COVERAGE_DATA[]` aggregated coverage map
  - [ ] `COVERAGE_BUFFER` I/O optimization buffer
  - [ ] `setup_coverage()` initialization function
  - [ ] `_coverage_tracker()` DEBUG trap handler
  - [ ] `_flush_buffer()` write buffer to file
  - [ ] `flush_coverage()` finalize test coverage
  - [ ] `aggregate_coverage()` combine all data
  - [ ] `get_coverage_stats()` calculate per-file stats
  - [ ] `_is_executable_line()` line classification
  - [ ] `generate_coverage_text()` console report
  - [ ] `generate_coverage_json()` JSON report
  - [ ] `check_coverage_threshold()` threshold verification
  - [ ] `cleanup_coverage()` temp file cleanup
  - [ ] File header documentation
  - [ ] All function docstrings

- [ ] **src/test_runner.sh** (modifications, ~80 lines)
  - [ ] Add `--coverage` argument parsing
  - [ ] Add `--coverage-report` argument parsing
  - [ ] Add `--coverage-threshold` argument parsing
  - [ ] Source coverage.sh when enabled
  - [ ] Inject `setup_coverage()` in test subshell
  - [ ] Inject `flush_coverage()` after test
  - [ ] Call `aggregate_coverage()` after all tests
  - [ ] Call report generation functions
  - [ ] Call threshold check
  - [ ] Call `cleanup_coverage()` at exit

- [ ] **src/report_template.html** (modifications, ~100 lines)
  - [ ] Coverage summary card
  - [ ] Coverage section container
  - [ ] Coverage table with per-file breakdown
  - [ ] Coverage progress bars
  - [ ] Line-by-line source view (collapsible)
  - [ ] CSS styles for coverage visualization
  - [ ] JavaScript for rendering coverage data

### 10.2 Test Deliverables

- [ ] **tests/coverage_test.sh** (new test file)
  - [ ] Test `setup_coverage()` creates temp dir
  - [ ] Test DEBUG trap is installed
  - [ ] Test `_is_executable_line()` classifications
  - [ ] Test `flush_coverage()` writes data
  - [ ] Test `aggregate_coverage()` combines files
  - [ ] Test `get_coverage_stats()` calculates correctly
  - [ ] Test `generate_coverage_text()` output format
  - [ ] Test `generate_coverage_json()` valid JSON
  - [ ] Test `check_coverage_threshold()` pass/fail
  - [ ] Test `cleanup_coverage()` removes temp files
  - [ ] Test coverage isolation between tests

- [ ] **tests/integration/coverage_integration_test.sh**
  - [ ] Test coverage with real test files
  - [ ] Test coverage with multiple test files
  - [ ] Test coverage with HTML report
  - [ ] Test coverage threshold enforcement
  - [ ] Test coverage JSON report validity
  - [ ] Test coverage combined with mocking
  - [ ] Test coverage combined with TAP output

### 10.3 Documentation Deliverables

- [ ] **README.md** updates
  - [ ] Coverage section
  - [ ] Usage examples
  - [ ] Limitations section
  - [ ] CI/CD integration example

- [ ] **CHANGELOG.md** entry
  - [ ] v0.4.0 release notes

- [ ] **Inline documentation**
  - [ ] coverage.sh file header
  - [ ] All function docstrings
  - [ ] Limitations warnings

### 10.4 Validation Deliverables

- [ ] Coverage data correctly collected
- [ ] Subshell isolation doesn't lose data
- [ ] Executable line detection accurate
- [ ] Coverage percentages calculated correctly
- [ ] Text report formatted properly
- [ ] JSON report valid and complete
- [ ] HTML report displays coverage
- [ ] Threshold enforcement works
- [ ] Temp files cleaned up
- [ ] No regression in existing test functionality
- [ ] Performance overhead documented

---

## 11. Testing Strategy

### 11.1 Unit Tests

```bash
# tests/coverage_test.sh

test_is_executable_line_simple_command() {
    source src/coverage.sh

    _is_executable_line 'echo "hello"'
    assert_equals 0 $?
}

test_is_executable_line_comment() {
    source src/coverage.sh

    _is_executable_line '# this is a comment'
    assert_equals 1 $?
}

test_is_executable_line_blank() {
    source src/coverage.sh

    _is_executable_line '   '
    assert_equals 1 $?
}

test_is_executable_line_function_def() {
    source src/coverage.sh

    _is_executable_line 'my_function() {'
    assert_equals 1 $?
}

test_is_executable_line_closing_brace() {
    source src/coverage.sh

    _is_executable_line '}'
    assert_equals 1 $?
}

test_setup_coverage_creates_dir() {
    source src/coverage.sh

    setup_coverage

    assert_true "[ -d \"$COVERAGE_DIR\" ]"

    cleanup_coverage
}

test_aggregate_coverage_deduplicates() {
    source src/coverage.sh

    COVERAGE_DIR=$(mktemp -d)
    echo "/path/file.sh:5" >> "$COVERAGE_DIR/test1.cov"
    echo "/path/file.sh:5" >> "$COVERAGE_DIR/test2.cov"
    echo "/path/file.sh:6" >> "$COVERAGE_DIR/test2.cov"

    aggregate_coverage

    # Should have 2 unique entries, not 3
    assert_equals 2 "${#COVERAGE_DATA[@]}"

    rm -rf "$COVERAGE_DIR"
}
```

### 11.2 Integration Tests

```bash
# tests/integration/coverage_integration_test.sh

test_coverage_with_real_script() {
    # Create test script
    cat > /tmp/testscript.sh << 'EOF'
#!/bin/bash
add() {
    local a=$1
    local b=$2
    echo $((a + b))
}
EOF

    # Create test file
    cat > /tmp/testscript_test.sh << 'EOF'
test_add() {
    source /tmp/testscript.sh
    result=$(add 2 3)
    assert_equals "5" "$result"
}
EOF

    # Run with coverage
    output=$(./src/test_runner.sh --coverage /tmp/testscript_test.sh)

    assert_output_contains "Coverage:" "echo '$output'"
    assert_output_contains "testscript.sh" "echo '$output'"

    rm /tmp/testscript.sh /tmp/testscript_test.sh
}

test_coverage_threshold_pass() {
    # Script with 100% coverage
    cat > /tmp/simple.sh << 'EOF'
greet() {
    echo "Hello"
}
EOF

    cat > /tmp/simple_test.sh << 'EOF'
test_greet() {
    source /tmp/simple.sh
    result=$(greet)
    assert_equals "Hello" "$result"
}
EOF

    ./src/test_runner.sh --coverage --coverage-threshold 80 /tmp/simple_test.sh
    assert_equals 0 $?

    rm /tmp/simple.sh /tmp/simple_test.sh
}

test_coverage_threshold_fail() {
    # Script with partial coverage
    cat > /tmp/partial.sh << 'EOF'
used() {
    echo "used"
}
unused() {
    echo "unused"
}
EOF

    cat > /tmp/partial_test.sh << 'EOF'
test_used() {
    source /tmp/partial.sh
    result=$(used)
    assert_equals "used" "$result"
}
EOF

    ./src/test_runner.sh --coverage --coverage-threshold 90 /tmp/partial_test.sh
    assert_equals 1 $?

    rm /tmp/partial.sh /tmp/partial_test.sh
}

test_coverage_json_valid() {
    # Create and run test with JSON output
    ./src/test_runner.sh --coverage --coverage-report /tmp/cov.json tests/

    # Validate JSON syntax
    python3 -c "import json; json.load(open('/tmp/cov.json'))"
    assert_equals 0 $?

    rm /tmp/cov.json
}
```

### 11.3 Performance Tests

```bash
# tests/performance/coverage_performance_test.sh

test_coverage_overhead() {
    # Run without coverage
    start=$(date +%s%N)
    ./src/test_runner.sh tests/ >/dev/null
    end=$(date +%s%N)
    baseline=$((end - start))

    # Run with coverage
    start=$(date +%s%N)
    ./src/test_runner.sh --coverage tests/ >/dev/null
    end=$(date +%s%N)
    with_coverage=$((end - start))

    # Calculate overhead
    overhead=$((with_coverage * 100 / baseline))

    echo "Baseline: ${baseline}ns"
    echo "With coverage: ${with_coverage}ns"
    echo "Overhead: ${overhead}%"

    # Should be less than 5x slower
    assert_true "[ $overhead -lt 500 ]"
}
```

---

## 12. Acceptance Criteria

### 12.1 Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-01 | `--coverage` enables coverage tracking | Run with flag, verify report generated |
| AC-02 | Coverage data collected in subshells | Check temp files contain line data |
| AC-03 | Executable lines correctly identified | Test with known script, verify count |
| AC-04 | Non-executable lines excluded | Comments, blanks not counted |
| AC-05 | Coverage percentage calculated correctly | Manual verification of math |
| AC-06 | Text report shows per-file breakdown | Verify output format |
| AC-07 | JSON report valid and complete | Parse with jq/python |
| AC-08 | HTML report includes coverage section | View in browser |
| AC-09 | `--coverage-threshold` enforced | Test pass/fail scenarios |
| AC-10 | Temp files cleaned up after run | Check no orphaned files |

### 12.2 Limitation Acknowledgment Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| LC-01 | Subshell `$()` lines not tracked | Document limitation, verify behavior |
| LC-02 | Process substitution `<()` not tracked | Document limitation, verify behavior |
| LC-03 | Background `&` commands not tracked | Document limitation, verify behavior |
| LC-04 | Works only on Bash 4.0+ | Version check implemented |
| LC-05 | Performance overhead acceptable (~2-5x) | Benchmark tests |

### 12.3 Integration Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| IG-01 | Works with existing assertions | Use assert_equals with coverage |
| IG-02 | Works with mocking | Coverage + mock_command together |
| IG-03 | Works with TAP output | --coverage --tap combination |
| IG-04 | Works with verbose mode | --coverage --verbose combination |
| IG-05 | Works with HTML reports | --coverage --html combination |
| IG-06 | Works with watch mode | --coverage --watch combination |

### 12.4 Error Handling Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| EH-01 | Graceful handling if no tests found | No crash, appropriate message |
| EH-02 | Threshold message clear | Shows actual vs required |
| EH-03 | File not found handled | Appropriate error message |
| EH-04 | Invalid threshold handled | Error for non-numeric |
| EH-05 | Cleanup on error | Temp files removed even on failure |

---

## Appendix A: Executable Line Classification Examples

### Lines That ARE Executable

```bash
x=5                          # Variable assignment
local y=10                   # Local variable
echo "hello"                 # Simple command
ls -la                       # Command with arguments
if [[ $x -eq 5 ]]; then     # Conditional test
while true; do              # Loop header
for i in 1 2 3; do          # For loop header
case $1 in                  # Case header
*)                          # Case pattern
return 0                    # Return statement
exit 1                      # Exit statement
function_call               # Function invocation
cmd1 | cmd2                 # Pipeline
cmd1 && cmd2                # Logical AND
```

### Lines That Are NOT Executable

```bash
#!/bin/bash                  # Shebang
# Comment                    # Comment
                             # Blank line
my_function() {              # Function definition
function other() {           # Alternative function syntax
}                            # Closing brace
fi                           # End if
done                         # End loop
esac                         # End case
then                         # Then keyword (part of if)
else                         # Else keyword
do                           # Do keyword (part of loop)
<<EOF                        # Heredoc start
EOF                          # Heredoc end
```

---

## Appendix B: Performance Optimization Strategies

### B.1 I/O Buffering

Instead of writing each line immediately:
```bash
# Slow - one write per line
echo "$file:$line" >> "$COVERAGE_FILE"
```

Buffer and batch writes:
```bash
# Fast - one write per 50 lines
COVERAGE_BUFFER+="$file:$line"$'\n'
((COVERAGE_BUFFER_SIZE++))
if ((COVERAGE_BUFFER_SIZE >= 50)); then
    printf "%s" "$COVERAGE_BUFFER" >> "$COVERAGE_FILE"
    COVERAGE_BUFFER=""
    COVERAGE_BUFFER_SIZE=0
fi
```

### B.2 Skip Internal Files Early

Filter shell-spec internals before any processing:
```bash
case "$source_file" in
    */coverage.sh|*/assertions.sh|*/mocking.sh)
        return  # Skip immediately
        ;;
esac
```

### B.3 Minimize String Operations

Avoid repeated path resolution:
```bash
# Cache resolved paths
declare -A RESOLVED_PATHS
if [[ -z "${RESOLVED_PATHS[$file]}" ]]; then
    RESOLVED_PATHS[$file]="$(cd "$(dirname "$file")" && pwd)/$(basename "$file")"
fi
```

---

## Appendix C: Troubleshooting Guide

### C.1 No Coverage Data Collected

**Symptoms**: Coverage report shows 0% for all files

**Possible Causes**:
1. Scripts run in external processes (not sourced)
2. DEBUG trap overwritten by test code
3. Test files not found

**Solutions**:
1. Ensure scripts are `source`d, not executed via subprocess
2. Check if test code sets its own `trap DEBUG`
3. Verify test file paths

### C.2 Inaccurate Line Counts

**Symptoms**: Executable line count seems wrong

**Possible Causes**:
1. Heredocs counted incorrectly
2. Multi-line strings
3. Line continuation with `\`

**Solutions**:
1. Review `_is_executable_line()` logic
2. Accept as known limitation
3. Document edge cases

### C.3 Performance Too Slow

**Symptoms**: Tests take >5x longer with coverage

**Possible Causes**:
1. Large test suite
2. Slow disk I/O
3. Buffer too small

**Solutions**:
1. Increase `COVERAGE_BUFFER_FLUSH_SIZE`
2. Use tmpfs/RAM disk for `COVERAGE_DIR`
3. Run coverage less frequently

---

*Document Version: 1.0*
*Last Updated: 2025-01-04*
*Status: Specification Complete - Ready for Implementation*
