# Shell-Spec v0.3.0 Specification: Mocking and Stubbing

## Overview

**Version**: 0.3.0
**Feature**: Mocking and Stubbing
**Status**: Planned
**Complexity**: Medium
**Estimated Lines of Code**: ~200 (new), ~30 (modifications)
**Dependencies**: v0.2.0 (TAP Output) should be complete first

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Architecture](#2-architecture)
3. [Functional Specification](#3-functional-specification)
4. [Technical Design](#4-technical-design)
5. [Workflows](#5-workflows)
6. [Use Cases](#6-use-cases)
7. [Decision Trees](#7-decision-trees)
8. [Logging & Diagnostics](#8-logging--diagnostics)
9. [Documentation Requirements](#9-documentation-requirements)
10. [Deliverables Checklist](#10-deliverables-checklist)
11. [Testing Strategy](#11-testing-strategy)
12. [Acceptance Criteria](#12-acceptance-criteria)

---

## 1. Executive Summary

### 1.1 Purpose

Add mocking and stubbing capabilities to shell-spec, enabling test isolation by temporarily replacing system commands and shell functions with controlled test doubles.

### 1.2 Goals

- Provide `mock_command` to shadow PATH commands with shell functions
- Provide `stub_function` to replace shell functions temporarily
- Automatic cleanup via `unmock_all` after each test
- Simple, intuitive API that integrates seamlessly with existing test patterns
- Zero external dependencies (pure shell implementation)

### 1.3 Non-Goals

- Mocking shell builtins (`cd`, `export`, `source`, `exit`, `eval`, `exec`, etc.)
- Call verification/spy functionality (counting calls, capturing arguments)
- Partial mocks (mocking only certain invocations)
- Mock chaining or sequencing
- Async mock behavior

### 1.4 Key Constraints

- Mocks must be test-scoped (no leakage between tests)
- Original implementations must be reliably restored
- Must work within existing subshell execution model
- Performance impact should be negligible

---

## 2. Architecture

### 2.1 Component Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           test_runner.sh                                │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    Test Execution Loop                          │   │
│  │                                                                 │   │
│  │   ┌─────────────┐    ┌─────────────────────────────────────┐   │   │
│  │   │  For each   │    │         Subshell Execution          │   │   │
│  │   │  test func  │───▶│                                     │   │   │
│  │   └─────────────┘    │  source assertions.sh               │   │   │
│  │                      │  source mocking.sh        ◀── NEW   │   │   │
│  │                      │  source test_file.sh                │   │   │
│  │                      │  $test_function                     │   │   │
│  │                      │  unmock_all              ◀── NEW   │   │   │
│  │                      └─────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │      src/mocking.sh           │  ◀── NEW FILE
                    │                               │
                    │  State Management:            │
                    │  • _MOCKED_COMMANDS[]         │
                    │  • _STUBBED_FUNCTIONS[]       │
                    │  • _ORIGINAL_FUNCTIONS[]      │
                    │                               │
                    │  Public API:                  │
                    │  • mock_command()             │
                    │  • stub_function()            │
                    │  • unmock_command()           │
                    │  • unstub_function()          │
                    │  • unmock_all()               │
                    │                               │
                    │  Internal Helpers:            │
                    │  • _is_shell_builtin()        │
                    │  • _save_original_function()  │
                    │  • _restore_function()        │
                    └───────────────────────────────┘
```

### 2.2 File Structure

```
src/
├── test_runner.sh      # MODIFY: Source mocking.sh, call unmock_all
├── mocking.sh          # NEW: Mocking/stubbing implementation
├── tap_reporter.sh     # NO CHANGE (from v0.2.0)
├── assertions.sh       # NO CHANGE
└── report_template.html # NO CHANGE
```

### 2.3 Mock Lifecycle Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Test Lifecycle                               │
└─────────────────────────────────────────────────────────────────────┘

  Test Start                                              Test End
      │                                                       │
      ▼                                                       ▼
┌───────────┐     ┌───────────┐     ┌───────────┐     ┌───────────┐
│  Subshell │────▶│   Mock    │────▶│   Test    │────▶│  Cleanup  │
│  Created  │     │   Setup   │     │  Executes │     │  (auto)   │
└───────────┘     └───────────┘     └───────────┘     └───────────┘
                        │                 │                 │
                        ▼                 ▼                 ▼
                  ┌───────────┐     ┌───────────┐     ┌───────────┐
                  │ mock_cmd  │     │ Call mock │     │unmock_all │
                  │ stub_func │     │ functions │     │ (restore) │
                  └───────────┘     └───────────┘     └───────────┘
                        │                                   │
                        ▼                                   ▼
                  ┌───────────┐                       ┌───────────┐
                  │ Original  │                       │ Subshell  │
                  │ saved to  │                       │  exits    │
                  │ _ORIGINAL │                       │ (cleanup) │
                  └───────────┘                       └───────────┘
```

### 2.4 Command Mocking Mechanism

```
┌─────────────────────────────────────────────────────────────────────┐
│                    How Command Mocking Works                        │
└─────────────────────────────────────────────────────────────────────┘

Before mock_command "curl" "echo mocked":

    Shell lookup order:
    1. Shell builtins      → (not curl)
    2. Shell functions     → (none defined)
    3. PATH executables    → /usr/bin/curl ✓

After mock_command "curl" "echo mocked":

    Shell lookup order:
    1. Shell builtins      → (not curl)
    2. Shell functions     → curl() { echo mocked; } ✓  ◀── INTERCEPTS
    3. PATH executables    → /usr/bin/curl (never reached)

Key insight: Shell functions take precedence over PATH commands,
so defining a function with the command's name shadows it.
```

### 2.5 Function Stubbing Mechanism

```
┌─────────────────────────────────────────────────────────────────────┐
│                   How Function Stubbing Works                       │
└─────────────────────────────────────────────────────────────────────┘

Before stub_function "helper" "return 0":

    helper() {
        # Original complex implementation
        curl -X POST ...
        process_data ...
        return $result
    }

    _ORIGINAL_FUNCTIONS["helper"] = "helper() { curl -X POST ... }"

After stub_function "helper" "return 0":

    helper() {
        return 0    ◀── Simple stub replaces original
    }

On unstub_function "helper" or unmock_all:

    eval "${_ORIGINAL_FUNCTIONS["helper"]}"   ◀── Restores original
```

---

## 3. Functional Specification

### 3.1 Public API

#### 3.1.1 mock_command

```bash
mock_command <command_name> <implementation>
```

**Purpose**: Replace a PATH command with a shell function.

**Parameters**:
- `command_name`: Name of command to mock (e.g., "curl", "git", "ls")
- `implementation`: Shell code to execute when command is called

**Returns**:
- 0: Success
- 1: Error (e.g., attempting to mock a builtin)

**Example**:
```bash
test_api_call() {
    mock_command "curl" 'echo {"status": "ok"}'

    result=$(my_function_that_calls_curl)

    assert_equals '{"status": "ok"}' "$result"
}
```

#### 3.1.2 stub_function

```bash
stub_function <function_name> <implementation>
```

**Purpose**: Replace a shell function with a stub.

**Parameters**:
- `function_name`: Name of function to stub
- `implementation`: Shell code to execute when function is called

**Returns**:
- 0: Success
- 1: Error (function not defined - optional warning)

**Example**:
```bash
test_with_stubbed_helper() {
    # Original helper does complex network calls
    stub_function "fetch_user_data" 'echo "John Doe"'

    result=$(process_user)

    assert_equals "Hello, John Doe" "$result"
}
```

#### 3.1.3 unmock_command

```bash
unmock_command <command_name>
```

**Purpose**: Restore a single mocked command to original behavior.

**Parameters**:
- `command_name`: Name of mocked command to restore

**Returns**:
- 0: Success
- 1: Command was not mocked

#### 3.1.4 unstub_function

```bash
unstub_function <function_name>
```

**Purpose**: Restore a single stubbed function to original implementation.

**Parameters**:
- `function_name`: Name of stubbed function to restore

**Returns**:
- 0: Success
- 1: Function was not stubbed

#### 3.1.5 unmock_all

```bash
unmock_all
```

**Purpose**: Restore all mocked commands and stubbed functions.

**Parameters**: None

**Returns**: 0 (always succeeds)

**Note**: Called automatically by test runner after each test.

### 3.2 Mock Behaviors

#### 3.2.1 Exit Codes

```bash
# Mock that always succeeds
mock_command "git" 'echo "mocked"; return 0'

# Mock that always fails
mock_command "curl" 'echo "error" >&2; return 1'

# Mock with conditional exit
mock_command "test_cmd" '
    if [[ "$1" == "--help" ]]; then
        echo "Usage: test_cmd [options]"
        return 0
    else
        return 1
    fi
'
```

#### 3.2.2 Argument Access

```bash
# Mocks receive all arguments passed to the command
mock_command "git" '
    echo "git called with: $@"
    echo "First arg: $1"
    echo "Second arg: $2"
'

# Test can then verify behavior based on arguments
test_git_commit() {
    mock_command "git" '
        if [[ "$1" == "commit" ]]; then
            echo "Commit successful"
        fi
    '
    result=$(my_git_wrapper commit -m "test")
    assert_output_contains "Commit successful" "echo $result"
}
```

#### 3.2.3 Standard Streams

```bash
# Mock with stdout output
mock_command "cat" 'echo "file contents"'

# Mock with stderr output
mock_command "failing_cmd" 'echo "error message" >&2; return 1'

# Mock with both
mock_command "verbose_cmd" '
    echo "normal output"
    echo "debug info" >&2
'
```

### 3.3 Shell Builtins (Not Supported)

The following cannot be mocked and will return an error:

| Builtin | Reason |
|---------|--------|
| `cd` | Changes shell state, cannot be overridden |
| `export` | Shell keyword |
| `source` / `.` | Shell keyword |
| `exit` | Terminates shell |
| `eval` | Shell keyword |
| `exec` | Replaces shell process |
| `return` | Shell keyword |
| `set` | Shell keyword |
| `unset` | Shell keyword |
| `readonly` | Shell keyword |
| `declare` | Shell keyword |
| `local` | Shell keyword |
| `trap` | Modifies signal handling |
| `builtin` | Meta-builtin |
| `command` | Meta-builtin |
| `type` | Shell builtin |
| `hash` | Shell builtin |

---

## 4. Technical Design

### 4.1 New File: `src/mocking.sh`

```bash
#!/bin/bash
# =============================================================================
# mocking.sh - Mocking and Stubbing Library for shell-spec
# =============================================================================
#
# Part of shell-spec testing framework
# https://github.com/southpawriter02/shell-spec
#
# This module provides functions to temporarily replace system commands and
# shell functions with test doubles (mocks/stubs), enabling isolated testing.
#
# Usage:
#   source mocking.sh
#   mock_command "curl" 'echo "mocked response"'
#   stub_function "helper" 'return 0'
#   # ... run tests ...
#   unmock_all  # Called automatically by test runner
#
# Limitations:
#   - Cannot mock shell builtins (cd, export, source, exit, etc.)
#   - No call verification (spy functionality)
#   - Mocks only work for unqualified command names
#
# =============================================================================

# === State Management ===
# Track mocked commands for cleanup
declare -a _SHELL_SPEC_MOCKED_COMMANDS=()

# Track stubbed functions for cleanup
declare -a _SHELL_SPEC_STUBBED_FUNCTIONS=()

# Store original function definitions for restoration
declare -A _SHELL_SPEC_ORIGINAL_FUNCTIONS=()

# List of shell builtins that cannot be mocked
readonly _SHELL_SPEC_BUILTINS="cd export source . exit eval exec return set unset readonly declare local trap builtin command type hash read echo printf test [ ]"

# === Internal Helper Functions ===

# _is_shell_builtin: Check if a command is a shell builtin
#
# Arguments:
#   $1 - command name to check
#
# Returns:
#   0 if builtin, 1 if not
#
_is_shell_builtin() {
    local cmd="$1"
    local builtin

    for builtin in $_SHELL_SPEC_BUILTINS; do
        if [[ "$cmd" == "$builtin" ]]; then
            return 0
        fi
    done

    # Also check with 'type' for any we might have missed
    if type -t "$cmd" 2>/dev/null | grep -q "builtin"; then
        return 0
    fi

    return 1
}

# _save_original_function: Save a function's definition before stubbing
#
# Arguments:
#   $1 - function name
#
# Returns:
#   0 if saved, 1 if function doesn't exist
#
_save_original_function() {
    local func_name="$1"

    if declare -f "$func_name" > /dev/null 2>&1; then
        _SHELL_SPEC_ORIGINAL_FUNCTIONS["$func_name"]="$(declare -f "$func_name")"
        return 0
    fi

    return 1
}

# _restore_function: Restore a function from saved definition
#
# Arguments:
#   $1 - function name
#
# Returns:
#   0 if restored, 1 if no saved definition
#
_restore_function() {
    local func_name="$1"

    if [[ -n "${_SHELL_SPEC_ORIGINAL_FUNCTIONS[$func_name]:-}" ]]; then
        eval "${_SHELL_SPEC_ORIGINAL_FUNCTIONS[$func_name]}"
        unset "_SHELL_SPEC_ORIGINAL_FUNCTIONS[$func_name]"
        return 0
    fi

    return 1
}

# _array_contains: Check if array contains a value
#
# Arguments:
#   $1 - value to find
#   $@ - array elements (pass as "${array[@]}")
#
# Returns:
#   0 if found, 1 if not
#
_array_contains() {
    local needle="$1"
    shift
    local element

    for element in "$@"; do
        if [[ "$element" == "$needle" ]]; then
            return 0
        fi
    done

    return 1
}

# _remove_from_array: Remove a value from array (updates global)
#
# Arguments:
#   $1 - array name (as string)
#   $2 - value to remove
#
_remove_from_array() {
    local array_name="$1"
    local value="$2"
    local -n arr="$array_name"
    local new_array=()
    local element

    for element in "${arr[@]}"; do
        if [[ "$element" != "$value" ]]; then
            new_array+=("$element")
        fi
    done

    arr=("${new_array[@]}")
}

# === Public API Functions ===

# mock_command: Replace a PATH command with a shell function
#
# Creates a shell function with the same name as the command, which takes
# precedence over PATH lookup. The function executes the provided implementation.
#
# Arguments:
#   $1 - command_name : Name of command to mock (required)
#   $2 - implementation : Shell code to execute (required)
#
# Returns:
#   0 - Success
#   1 - Error (attempted to mock a builtin)
#
# Example:
#   mock_command "curl" 'echo "mocked response"; return 0'
#   mock_command "git" 'echo "git called with: $@"'
#
mock_command() {
    local cmd_name="$1"
    local implementation="$2"

    # Validate arguments
    if [[ -z "$cmd_name" ]]; then
        echo "mock_command: command name required" >&2
        return 1
    fi

    if [[ -z "$implementation" ]]; then
        echo "mock_command: implementation required" >&2
        return 1
    fi

    # Check if it's a builtin
    if _is_shell_builtin "$cmd_name"; then
        echo "mock_command: cannot mock shell builtin '$cmd_name'" >&2
        return 1
    fi

    # Check if already mocked
    if _array_contains "$cmd_name" "${_SHELL_SPEC_MOCKED_COMMANDS[@]}"; then
        echo "mock_command: '$cmd_name' is already mocked (call unmock_command first)" >&2
        return 1
    fi

    # Track for cleanup
    _SHELL_SPEC_MOCKED_COMMANDS+=("$cmd_name")

    # Create the mock function
    # Using eval to properly handle the implementation string
    eval "${cmd_name}() { ${implementation}; }"

    # Export the function so it's available in subshells
    export -f "$cmd_name" 2>/dev/null || true

    return 0
}

# stub_function: Replace a shell function with a stub implementation
#
# Saves the original function definition (if it exists) and replaces it
# with the provided stub implementation.
#
# Arguments:
#   $1 - function_name : Name of function to stub (required)
#   $2 - implementation : Shell code to execute (required)
#
# Returns:
#   0 - Success
#   1 - Error
#
# Example:
#   stub_function "fetch_data" 'echo "stubbed data"; return 0'
#   stub_function "complex_helper" 'return 0'
#
stub_function() {
    local func_name="$1"
    local implementation="$2"

    # Validate arguments
    if [[ -z "$func_name" ]]; then
        echo "stub_function: function name required" >&2
        return 1
    fi

    if [[ -z "$implementation" ]]; then
        echo "stub_function: implementation required" >&2
        return 1
    fi

    # Check if already stubbed
    if _array_contains "$func_name" "${_SHELL_SPEC_STUBBED_FUNCTIONS[@]}"; then
        echo "stub_function: '$func_name' is already stubbed (call unstub_function first)" >&2
        return 1
    fi

    # Save original if it exists
    _save_original_function "$func_name"

    # Track for cleanup
    _SHELL_SPEC_STUBBED_FUNCTIONS+=("$func_name")

    # Create the stub function
    eval "${func_name}() { ${implementation}; }"

    return 0
}

# unmock_command: Restore a single mocked command
#
# Removes the mock function, allowing the original PATH command to be found.
#
# Arguments:
#   $1 - command_name : Name of mocked command to restore
#
# Returns:
#   0 - Success
#   1 - Command was not mocked
#
# Example:
#   unmock_command "curl"
#
unmock_command() {
    local cmd_name="$1"

    if [[ -z "$cmd_name" ]]; then
        echo "unmock_command: command name required" >&2
        return 1
    fi

    # Check if it was mocked
    if ! _array_contains "$cmd_name" "${_SHELL_SPEC_MOCKED_COMMANDS[@]}"; then
        echo "unmock_command: '$cmd_name' is not mocked" >&2
        return 1
    fi

    # Remove the function
    unset -f "$cmd_name" 2>/dev/null

    # Remove from tracking array
    _remove_from_array "_SHELL_SPEC_MOCKED_COMMANDS" "$cmd_name"

    return 0
}

# unstub_function: Restore a single stubbed function
#
# Restores the original function definition if it existed, or removes
# the stub if there was no original.
#
# Arguments:
#   $1 - function_name : Name of stubbed function to restore
#
# Returns:
#   0 - Success
#   1 - Function was not stubbed
#
# Example:
#   unstub_function "helper_func"
#
unstub_function() {
    local func_name="$1"

    if [[ -z "$func_name" ]]; then
        echo "unstub_function: function name required" >&2
        return 1
    fi

    # Check if it was stubbed
    if ! _array_contains "$func_name" "${_SHELL_SPEC_STUBBED_FUNCTIONS[@]}"; then
        echo "unstub_function: '$func_name' is not stubbed" >&2
        return 1
    fi

    # Restore original or remove stub
    if ! _restore_function "$func_name"; then
        # No original existed, just unset the stub
        unset -f "$func_name" 2>/dev/null
    fi

    # Remove from tracking array
    _remove_from_array "_SHELL_SPEC_STUBBED_FUNCTIONS" "$func_name"

    return 0
}

# unmock_all: Restore all mocked commands and stubbed functions
#
# This function is called automatically by the test runner after each test
# to ensure clean state. Can also be called manually if needed.
#
# Arguments: None
#
# Returns: 0 (always succeeds)
#
# Example:
#   unmock_all
#
unmock_all() {
    local cmd
    local func

    # Restore all mocked commands
    for cmd in "${_SHELL_SPEC_MOCKED_COMMANDS[@]}"; do
        unset -f "$cmd" 2>/dev/null
    done
    _SHELL_SPEC_MOCKED_COMMANDS=()

    # Restore all stubbed functions
    for func in "${_SHELL_SPEC_STUBBED_FUNCTIONS[@]}"; do
        if [[ -n "${_SHELL_SPEC_ORIGINAL_FUNCTIONS[$func]:-}" ]]; then
            eval "${_SHELL_SPEC_ORIGINAL_FUNCTIONS[$func]}"
        else
            unset -f "$func" 2>/dev/null
        fi
    done
    _SHELL_SPEC_STUBBED_FUNCTIONS=()
    _SHELL_SPEC_ORIGINAL_FUNCTIONS=()

    return 0
}

# === Diagnostic Functions ===

# list_mocks: List all currently active mocks (for debugging)
#
# Arguments: None
#
# Output: List of mocked commands and stubbed functions
#
list_mocks() {
    echo "Mocked commands: ${_SHELL_SPEC_MOCKED_COMMANDS[*]:-none}"
    echo "Stubbed functions: ${_SHELL_SPEC_STUBBED_FUNCTIONS[*]:-none}"
}

# is_mocked: Check if a command is currently mocked
#
# Arguments:
#   $1 - command name
#
# Returns:
#   0 if mocked, 1 if not
#
is_mocked() {
    _array_contains "$1" "${_SHELL_SPEC_MOCKED_COMMANDS[@]}"
}

# is_stubbed: Check if a function is currently stubbed
#
# Arguments:
#   $1 - function name
#
# Returns:
#   0 if stubbed, 1 if not
#
is_stubbed() {
    _array_contains "$1" "${_SHELL_SPEC_STUBBED_FUNCTIONS[@]}"
}
```

### 4.2 Modifications to `src/test_runner.sh`

#### 4.2.1 Source mocking library (after line 31, after assertions)

```bash
source "$SCRIPT_DIR/assertions.sh"
source "$SCRIPT_DIR/tap_reporter.sh"
source "$SCRIPT_DIR/mocking.sh"  # NEW
```

#### 4.2.2 Add unmock_all to test execution (lines 155-161)

Current:
```bash
output=$(
  (
    source "$SCRIPT_DIR/assertions.sh"
    source "$file"
    $func
  ) 2>&1
)
```

Modified:
```bash
output=$(
  (
    source "$SCRIPT_DIR/assertions.sh"
    source "$SCRIPT_DIR/mocking.sh"  # NEW
    source "$file"
    $func
    unmock_all  # NEW: Ensure cleanup even if test doesn't call it
  ) 2>&1
)
```

---

## 5. Workflows

### 5.1 Command Mocking Workflow

```
┌─────────────────────────────────────────────────────────────────┐
│              User calls: mock_command "curl" 'echo hi'          │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 1. Validate arguments                                           │
│    • Check command_name is not empty                            │
│    • Check implementation is not empty                          │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Check for shell builtin                                      │
│    • If builtin → return error with message                     │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. Check if already mocked                                      │
│    • If already in _MOCKED_COMMANDS → return error              │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. Track for cleanup                                            │
│    • Add to _SHELL_SPEC_MOCKED_COMMANDS array                   │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 5. Create mock function                                         │
│    • eval "curl() { echo hi; }"                                 │
│    • export -f curl (for subshells)                             │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 6. Return success                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 Function Stubbing Workflow

```
┌─────────────────────────────────────────────────────────────────┐
│          User calls: stub_function "helper" 'return 0'          │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 1. Validate arguments                                           │
│    • Check function_name is not empty                           │
│    • Check implementation is not empty                          │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Check if already stubbed                                     │
│    • If already in _STUBBED_FUNCTIONS → return error            │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. Save original function (if exists)                           │
│    • original = $(declare -f helper)                            │
│    • _ORIGINAL_FUNCTIONS["helper"] = original                   │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. Track for cleanup                                            │
│    • Add to _SHELL_SPEC_STUBBED_FUNCTIONS array                 │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 5. Create stub function                                         │
│    • eval "helper() { return 0; }"                              │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 6. Return success                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 Cleanup Workflow (unmock_all)

```
┌─────────────────────────────────────────────────────────────────┐
│               Test runner calls: unmock_all                     │
│           (automatically after each test function)              │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 1. Iterate mocked commands                                      │
│    for cmd in _MOCKED_COMMANDS:                                 │
│        unset -f $cmd                                            │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Clear mocked commands array                                  │
│    _MOCKED_COMMANDS=()                                          │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. Iterate stubbed functions                                    │
│    for func in _STUBBED_FUNCTIONS:                              │
│        if original exists:                                      │
│            eval original_definition                             │
│        else:                                                    │
│            unset -f $func                                       │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. Clear all tracking arrays                                    │
│    _STUBBED_FUNCTIONS=()                                        │
│    _ORIGINAL_FUNCTIONS=()                                       │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ 5. Return success                                               │
│    (Note: subshell exit also cleans up naturally)               │
└─────────────────────────────────────────────────────────────────┘
```

### 5.4 Test Isolation Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                    Test Isolation Guarantee                     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   test_one()    │     │   test_two()    │     │  test_three()   │
└────────┬────────┘     └────────┬────────┘     └────────┬────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│    Subshell 1   │     │    Subshell 2   │     │   Subshell 3    │
│                 │     │                 │     │                 │
│ mock_cmd "curl" │     │ mock_cmd "git"  │     │ (no mocks)      │
│ stub_func "a"   │     │                 │     │                 │
│                 │     │                 │     │                 │
│ ... test code...│     │ ... test code...│     │ ... test code...│
│                 │     │                 │     │                 │
│ unmock_all      │     │ unmock_all      │     │ unmock_all      │
│ EXIT            │     │ EXIT            │     │ EXIT            │
└─────────────────┘     └─────────────────┘     └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
   Clean state             Clean state             Clean state
   (subshell gone)         (subshell gone)         (subshell gone)

Key: Each test runs in isolated subshell. Mocks cannot leak because:
1. unmock_all is called explicitly before subshell exits
2. Subshell exit destroys all function definitions anyway
3. Parent shell state is never modified
```

---

## 6. Use Cases

### 6.1 UC-01: Mock HTTP Client (curl)

**Actor**: Developer testing API integration
**Precondition**: Function makes curl calls
**Goal**: Test without network access

```bash
# my_api.sh
fetch_user() {
    local user_id="$1"
    curl -s "https://api.example.com/users/$user_id"
}

# my_api_test.sh
test_fetch_user_returns_json() {
    mock_command "curl" 'echo "{\"id\": 123, \"name\": \"John\"}"'

    result=$(fetch_user 123)

    assert_output_contains '"name": "John"' "echo '$result'"
}

test_fetch_user_handles_error() {
    mock_command "curl" 'echo "Connection refused" >&2; return 1'

    # Function should handle curl failure gracefully
    result=$(fetch_user 999)
    exit_code=$?

    assert_equals 1 "$exit_code"
}
```

### 6.2 UC-02: Mock File System Commands

**Actor**: Developer testing file operations
**Goal**: Test without creating real files

```bash
# file_processor.sh
process_files() {
    local dir="$1"
    for file in $(ls "$dir"); do
        cat "$dir/$file" | wc -l
    done
}

# file_processor_test.sh
test_process_files_counts_lines() {
    mock_command "ls" 'echo -e "file1.txt\nfile2.txt"'
    mock_command "cat" 'echo -e "line1\nline2\nline3"'

    result=$(process_files "/fake/dir")

    # Each file should report 3 lines
    assert_output_contains "3" "echo '$result'"
}
```

### 6.3 UC-03: Stub Complex Helper Function

**Actor**: Developer isolating unit under test
**Goal**: Replace complex helper with simple stub

```bash
# main_logic.sh
calculate_price() {
    local product_id="$1"
    local quantity="$2"

    base_price=$(fetch_price_from_database "$product_id")
    discount=$(calculate_discount "$quantity")

    echo $((base_price * quantity - discount))
}

fetch_price_from_database() {
    # Complex database query...
}

calculate_discount() {
    # Complex discount rules...
}

# main_logic_test.sh
test_calculate_price_applies_discount() {
    source main_logic.sh

    stub_function "fetch_price_from_database" 'echo 100'
    stub_function "calculate_discount" 'echo 20'

    result=$(calculate_price "PROD001" 5)

    # 100 * 5 - 20 = 480
    assert_equals "480" "$result"
}
```

### 6.4 UC-04: Mock Git Commands

**Actor**: Developer testing git wrapper
**Goal**: Test git operations without real repo

```bash
# git_helper.sh
get_current_branch() {
    git rev-parse --abbrev-ref HEAD
}

has_uncommitted_changes() {
    if git diff --quiet HEAD 2>/dev/null; then
        return 1  # No changes
    else
        return 0  # Has changes
    fi
}

# git_helper_test.sh
test_get_current_branch() {
    mock_command "git" '
        if [[ "$1" == "rev-parse" ]]; then
            echo "feature/test-branch"
        fi
    '

    result=$(get_current_branch)

    assert_equals "feature/test-branch" "$result"
}

test_has_uncommitted_changes_when_clean() {
    mock_command "git" '
        if [[ "$1" == "diff" ]]; then
            return 0  # No diff = clean
        fi
    '

    has_uncommitted_changes

    assert_equals 1 $?  # Should return 1 (no changes)
}
```

### 6.5 UC-05: Multiple Mocks in Single Test

**Actor**: Developer testing complex integration
**Goal**: Control multiple external dependencies

```bash
# deploy.sh
deploy_application() {
    local version="$1"

    # Build
    npm run build || return 1

    # Upload
    aws s3 sync ./dist s3://my-bucket/ || return 1

    # Notify
    curl -X POST "https://slack.com/webhook" \
        -d "{\"text\": \"Deployed $version\"}" || return 1

    echo "Deployment complete"
}

# deploy_test.sh
test_deploy_success() {
    mock_command "npm" 'echo "Build complete"'
    mock_command "aws" 'echo "Upload complete"'
    mock_command "curl" 'echo "Notification sent"'

    result=$(deploy_application "1.0.0")

    assert_output_contains "Deployment complete" "echo '$result'"
}

test_deploy_fails_on_build_error() {
    mock_command "npm" 'echo "Build failed" >&2; return 1'
    mock_command "aws" 'echo "Should not reach here"'
    mock_command "curl" 'echo "Should not reach here"'

    deploy_application "1.0.0"

    assert_equals 1 $?
}
```

### 6.6 UC-06: Verify Mock is Cleaned Up

**Actor**: Developer ensuring test isolation
**Goal**: Confirm mocks don't leak

```bash
# isolation_test.sh
test_first_uses_mock() {
    mock_command "echo" 'printf "MOCKED"'

    result=$(echo "hello")

    assert_equals "MOCKED" "$result"
}

test_second_no_mock() {
    # This test runs after test_first_uses_mock
    # Echo should be back to normal

    result=$(echo "hello")

    assert_equals "hello" "$result"  # NOT "MOCKED"
}
```

---

## 7. Decision Trees

### 7.1 mock_command Decision Flow

```
                    ┌─────────────────────────┐
                    │  mock_command called    │
                    │  with name, impl        │
                    └───────────┬─────────────┘
                                │
                    ┌───────────┴───────────┐
                    │  Is name empty?       │
                    └───────────┬───────────┘
                                │
              ┌─────────────────┴─────────────────┐
              │ Yes                               │ No
              ▼                                   ▼
    ┌──────────────────┐              ┌───────────────────────┐
    │ Error: "command  │              │ Is impl empty?        │
    │ name required"   │              └───────────┬───────────┘
    │ return 1         │                          │
    └──────────────────┘            ┌─────────────┴─────────────┐
                                    │ Yes                       │ No
                                    ▼                           ▼
                          ┌──────────────────┐      ┌───────────────────────┐
                          │ Error: "impl     │      │ Is shell builtin?     │
                          │ required"        │      └───────────┬───────────┘
                          │ return 1         │                  │
                          └──────────────────┘    ┌─────────────┴─────────────┐
                                                  │ Yes                       │ No
                                                  ▼                           ▼
                                        ┌──────────────────┐      ┌───────────────────────┐
                                        │ Error: "cannot   │      │ Already mocked?       │
                                        │ mock builtin"    │      └───────────┬───────────┘
                                        │ return 1         │                  │
                                        └──────────────────┘    ┌─────────────┴─────────────┐
                                                                │ Yes                       │ No
                                                                ▼                           ▼
                                                      ┌──────────────────┐      ┌───────────────────┐
                                                      │ Error: "already  │      │ Add to tracking   │
                                                      │ mocked"          │      │ Create function   │
                                                      │ return 1         │      │ export -f         │
                                                      └──────────────────┘      │ return 0          │
                                                                                └───────────────────┘
```

### 7.2 stub_function Decision Flow

```
                    ┌─────────────────────────┐
                    │  stub_function called   │
                    │  with name, impl        │
                    └───────────┬─────────────┘
                                │
                    ┌───────────┴───────────┐
                    │  Validate arguments   │
                    └───────────┬───────────┘
                                │
              ┌─────────────────┴─────────────────┐
              │ Invalid                           │ Valid
              ▼                                   ▼
    ┌──────────────────┐              ┌───────────────────────┐
    │ Error message    │              │ Already stubbed?      │
    │ return 1         │              └───────────┬───────────┘
    └──────────────────┘                          │
                                    ┌─────────────┴─────────────┐
                                    │ Yes                       │ No
                                    ▼                           ▼
                          ┌──────────────────┐      ┌───────────────────────┐
                          │ Error: "already  │      │ Does original exist?  │
                          │ stubbed"         │      └───────────┬───────────┘
                          │ return 1         │                  │
                          └──────────────────┘    ┌─────────────┴─────────────┐
                                                  │ Yes                       │ No
                                                  ▼                           ▼
                                        ┌──────────────────┐      ┌───────────────────┐
                                        │ Save original:   │      │ (no original to   │
                                        │ declare -f       │      │  save)            │
                                        │ to _ORIGINAL     │      └─────────┬─────────┘
                                        └────────┬─────────┘                │
                                                 │                          │
                                                 └──────────┬───────────────┘
                                                            ▼
                                                  ┌───────────────────┐
                                                  │ Add to tracking   │
                                                  │ Create function   │
                                                  │ return 0          │
                                                  └───────────────────┘
```

### 7.3 unmock_all Decision Flow

```
                    ┌─────────────────────────┐
                    │    unmock_all called    │
                    └───────────┬─────────────┘
                                │
                    ┌───────────┴───────────┐
                    │ For each mocked cmd   │
                    └───────────┬───────────┘
                                │
                                ▼
                    ┌───────────────────────┐
                    │   unset -f $cmd       │
                    │   (remove function)   │
                    └───────────┬───────────┘
                                │
                    ┌───────────┴───────────┐
                    │ Clear _MOCKED_CMDS    │
                    └───────────┬───────────┘
                                │
                    ┌───────────┴───────────┐
                    │ For each stubbed func │
                    └───────────┬───────────┘
                                │
              ┌─────────────────┴─────────────────┐
              │                                   │
              ▼                                   ▼
    ┌──────────────────┐              ┌──────────────────┐
    │ Has original?    │              │ Has original?    │
    │ Yes              │              │ No               │
    └────────┬─────────┘              └────────┬─────────┘
             │                                  │
             ▼                                  ▼
    ┌──────────────────┐              ┌──────────────────┐
    │ eval original    │              │ unset -f $func   │
    │ (restore)        │              │ (just remove)    │
    └────────┬─────────┘              └────────┬─────────┘
             │                                  │
             └──────────────┬───────────────────┘
                            │
                            ▼
                  ┌───────────────────┐
                  │ Clear all arrays  │
                  │ return 0          │
                  └───────────────────┘
```

---

## 8. Logging & Diagnostics

### 8.1 Error Messages

All error messages are written to stderr with clear, actionable text:

| Condition | Message |
|-----------|---------|
| Empty command name | `mock_command: command name required` |
| Empty implementation | `mock_command: implementation required` |
| Mock builtin attempt | `mock_command: cannot mock shell builtin 'cd'` |
| Already mocked | `mock_command: 'curl' is already mocked (call unmock_command first)` |
| Unmock non-mocked | `unmock_command: 'curl' is not mocked` |
| Empty function name | `stub_function: function name required` |
| Already stubbed | `stub_function: 'helper' is already stubbed (call unstub_function first)` |
| Unstub non-stubbed | `unstub_function: 'helper' is not stubbed` |

### 8.2 Diagnostic Functions

```bash
# List all active mocks (for debugging)
list_mocks
# Output:
# Mocked commands: curl git aws
# Stubbed functions: fetch_data calculate_discount

# Check if specific command is mocked
if is_mocked "curl"; then
    echo "curl is currently mocked"
fi

# Check if specific function is stubbed
if is_stubbed "helper"; then
    echo "helper is currently stubbed"
fi
```

### 8.3 Verbose Mode (Future Enhancement)

Future versions may add verbose mode for debugging:

```bash
# With SHELL_SPEC_MOCK_VERBOSE=1
mock_command "curl" 'echo "test"'
# Output: [mock] Created mock for command 'curl'

unmock_all
# Output: [mock] Restored command 'curl'
# Output: [mock] Restored function 'helper'
# Output: [mock] Cleanup complete: 1 commands, 1 functions
```

---

## 9. Documentation Requirements

### 9.1 Inline Documentation

#### 9.1.1 File Header

```bash
#!/bin/bash
# =============================================================================
# mocking.sh - Mocking and Stubbing Library for shell-spec
# =============================================================================
#
# Part of shell-spec testing framework
# https://github.com/southpawriter02/shell-spec
#
# This module provides functions to temporarily replace system commands and
# shell functions with test doubles (mocks/stubs), enabling isolated testing.
#
# Usage:
#   source mocking.sh
#   mock_command "curl" 'echo "mocked response"'
#   stub_function "helper" 'return 0'
#   # ... run tests ...
#   unmock_all  # Called automatically by test runner
#
# Limitations:
#   - Cannot mock shell builtins (cd, export, source, exit, etc.)
#   - No call verification (spy functionality)
#   - Mocks only work for unqualified command names
#
# =============================================================================
```

#### 9.1.2 Function Documentation

Each public function must have:

```bash
# function_name: Brief one-line description
#
# Detailed description of behavior, including any important notes
# about side effects or state changes.
#
# Arguments:
#   $1 - param_name : Description (required/optional)
#   $2 - param_name : Description (optional, default: value)
#
# Returns:
#   0 - Success case description
#   1 - Error case description
#
# Side Effects:
#   - Modifies _SHELL_SPEC_MOCKED_COMMANDS array
#   - Creates/removes shell functions
#
# Example:
#   mock_command "curl" 'echo "response"; return 0'
#
```

### 9.2 README.md Updates

Add new section for mocking:

```markdown
## Mocking and Stubbing

shell-spec provides functions to replace commands and functions with test doubles.

### Mocking Commands

Replace a PATH command with a mock:

```bash
test_api_call() {
    mock_command "curl" 'echo {"status": "ok"}'

    result=$(my_function_that_uses_curl)

    assert_equals '{"status": "ok"}' "$result"
}
```

### Stubbing Functions

Replace a shell function with a stub:

```bash
test_with_stub() {
    stub_function "complex_helper" 'echo "stubbed"'

    result=$(function_that_calls_helper)

    assert_equals "stubbed" "$result"
}
```

### Automatic Cleanup

Mocks are automatically cleaned up after each test. You can also manually
restore them:

```bash
unmock_command "curl"      # Restore single command
unstub_function "helper"   # Restore single function
unmock_all                 # Restore everything
```

### Limitations

- Cannot mock shell builtins: `cd`, `export`, `source`, `exit`, etc.
- Mocks only work for unqualified command names (not `/usr/bin/curl`)
- No call verification (spy functionality) - use assertions instead
```

### 9.3 Changelog Entry

```markdown
## [0.3.0] - YYYY-MM-DD

### Added
- Mocking and stubbing library (`src/mocking.sh`)
- `mock_command` function to replace PATH commands with test doubles
- `stub_function` function to replace shell functions
- `unmock_command` and `unstub_function` for individual restoration
- `unmock_all` for complete cleanup (called automatically after each test)
- `list_mocks`, `is_mocked`, `is_stubbed` diagnostic functions
- Automatic cleanup integration in test runner

### Changed
- test_runner.sh now sources mocking.sh
- Test execution includes automatic unmock_all call
```

---

## 10. Deliverables Checklist

### 10.1 Code Deliverables

- [ ] **src/mocking.sh** (new file, ~200 lines)
  - [ ] `_SHELL_SPEC_MOCKED_COMMANDS` array
  - [ ] `_SHELL_SPEC_STUBBED_FUNCTIONS` array
  - [ ] `_SHELL_SPEC_ORIGINAL_FUNCTIONS` associative array
  - [ ] `_SHELL_SPEC_BUILTINS` readonly list
  - [ ] `_is_shell_builtin()` internal helper
  - [ ] `_save_original_function()` internal helper
  - [ ] `_restore_function()` internal helper
  - [ ] `_array_contains()` internal helper
  - [ ] `_remove_from_array()` internal helper
  - [ ] `mock_command()` public function
  - [ ] `stub_function()` public function
  - [ ] `unmock_command()` public function
  - [ ] `unstub_function()` public function
  - [ ] `unmock_all()` public function
  - [ ] `list_mocks()` diagnostic function
  - [ ] `is_mocked()` diagnostic function
  - [ ] `is_stubbed()` diagnostic function
  - [ ] File header documentation
  - [ ] All function docstrings

- [ ] **src/test_runner.sh** (modifications, ~10 lines)
  - [ ] Add `source "$SCRIPT_DIR/mocking.sh"`
  - [ ] Add `source mocking.sh` in subshell
  - [ ] Add `unmock_all` call after test execution

### 10.2 Test Deliverables

- [ ] **tests/mocking_test.sh** (new test file)
  - [ ] Test `mock_command` creates function
  - [ ] Test `mock_command` receives arguments
  - [ ] Test `mock_command` rejects builtins
  - [ ] Test `mock_command` rejects double-mock
  - [ ] Test `stub_function` replaces function
  - [ ] Test `stub_function` saves original
  - [ ] Test `unstub_function` restores original
  - [ ] Test `unmock_all` clears everything
  - [ ] Test mock isolation between tests
  - [ ] Test `list_mocks` output
  - [ ] Test `is_mocked` return value
  - [ ] Test `is_stubbed` return value
  - [ ] Test error messages format

- [ ] **tests/integration/mock_integration_test.sh**
  - [ ] Test mocking in real test scenarios
  - [ ] Test multiple mocks in single test
  - [ ] Test mock with TAP output
  - [ ] Test mock with verbose mode
  - [ ] Test mock cleanup on test failure

### 10.3 Documentation Deliverables

- [ ] **README.md** updates
  - [ ] Mocking section
  - [ ] Stubbing section
  - [ ] Limitations section
  - [ ] Examples

- [ ] **CHANGELOG.md** entry
  - [ ] v0.3.0 release notes

- [ ] **Inline documentation**
  - [ ] mocking.sh file header
  - [ ] All function docstrings

### 10.4 Validation Deliverables

- [ ] Mocks do not leak between tests
- [ ] Original commands restored after unmock
- [ ] Original functions restored after unstub
- [ ] Builtins properly rejected with clear error
- [ ] No regression in existing test functionality

---

## 11. Testing Strategy

### 11.1 Unit Tests

```bash
# tests/mocking_test.sh

test_mock_command_creates_function() {
    source src/mocking.sh

    mock_command "test_cmd" 'echo "mocked"'

    # Verify function exists
    assert_is_function "test_cmd"

    # Verify it outputs correctly
    result=$(test_cmd)
    assert_equals "mocked" "$result"

    unmock_all
}

test_mock_command_receives_arguments() {
    source src/mocking.sh

    mock_command "test_cmd" 'echo "args: $@"'

    result=$(test_cmd arg1 arg2 arg3)

    assert_equals "args: arg1 arg2 arg3" "$result"

    unmock_all
}

test_mock_command_rejects_builtin() {
    source src/mocking.sh

    mock_command "cd" 'echo "mocked"' 2>/dev/null
    exit_code=$?

    assert_equals 1 "$exit_code"
}

test_stub_function_saves_original() {
    source src/mocking.sh

    # Define original
    original_func() { echo "original"; }

    # Stub it
    stub_function "original_func" 'echo "stubbed"'

    # Verify stub works
    result=$(original_func)
    assert_equals "stubbed" "$result"

    # Restore
    unstub_function "original_func"

    # Verify original restored
    result=$(original_func)
    assert_equals "original" "$result"
}

test_unmock_all_clears_everything() {
    source src/mocking.sh

    mock_command "cmd1" 'echo "m1"'
    mock_command "cmd2" 'echo "m2"'
    stub_function "func1" 'echo "s1"'

    unmock_all

    # Verify all cleared
    assert_equals "none" "$(list_mocks | grep "Mocked" | awk '{print $NF}')"
}
```

### 11.2 Isolation Tests

```bash
# tests/isolation_test.sh

test_mock_does_not_leak_to_next_test_1() {
    mock_command "leaky_cmd" 'echo "from test 1"'

    result=$(leaky_cmd)
    assert_equals "from test 1" "$result"
}

test_mock_does_not_leak_to_next_test_2() {
    # leaky_cmd should not be defined here
    # (unless it's a real command in PATH)

    if type leaky_cmd 2>/dev/null | grep -q "function"; then
        # It's a function - mock leaked!
        assert_equals "no leak" "mock leaked"
    else
        # Not a function - correct behavior
        assert_equals "no leak" "no leak"
    fi
}
```

### 11.3 Integration Tests

```bash
# tests/integration/mock_integration_test.sh

test_mock_with_real_script() {
    # Create a temp script that uses curl
    cat > /tmp/api_script.sh << 'EOF'
fetch_data() {
    curl -s "https://api.example.com/data"
}
EOF

    source /tmp/api_script.sh

    mock_command "curl" 'echo "{\"result\": \"success\"}"'

    result=$(fetch_data)

    assert_output_contains "success" "echo '$result'"

    rm /tmp/api_script.sh
}

test_multiple_mocks_in_complex_test() {
    mock_command "git" 'echo "main"'
    mock_command "npm" 'echo "installed"'
    mock_command "curl" 'echo "notified"'

    # Simulate a deployment script
    branch=$(git branch --show-current)
    npm_result=$(npm install)
    notify_result=$(curl -X POST webhook)

    assert_equals "main" "$branch"
    assert_equals "installed" "$npm_result"
    assert_equals "notified" "$notify_result"
}
```

### 11.4 Error Handling Tests

```bash
# tests/mocking_errors_test.sh

test_mock_empty_name_fails() {
    source src/mocking.sh

    output=$(mock_command "" 'echo test' 2>&1)
    exit_code=$?

    assert_equals 1 "$exit_code"
    assert_output_contains "command name required" "echo '$output'"
}

test_mock_empty_impl_fails() {
    source src/mocking.sh

    output=$(mock_command "test" "" 2>&1)
    exit_code=$?

    assert_equals 1 "$exit_code"
    assert_output_contains "implementation required" "echo '$output'"
}

test_double_mock_fails() {
    source src/mocking.sh

    mock_command "test_cmd" 'echo "first"'
    output=$(mock_command "test_cmd" 'echo "second"' 2>&1)
    exit_code=$?

    assert_equals 1 "$exit_code"
    assert_output_contains "already mocked" "echo '$output'"

    unmock_all
}
```

---

## 12. Acceptance Criteria

### 12.1 Functional Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| AC-01 | `mock_command` creates function that shadows command | Call mocked command, verify mock output |
| AC-02 | Mock receives all arguments passed to command | Mock echoes `$@`, verify all args present |
| AC-03 | Mock exit code can be controlled | Mock returns 1, verify caller sees exit 1 |
| AC-04 | `stub_function` replaces existing function | Call stubbed function, verify stub output |
| AC-05 | `stub_function` saves original for restoration | Unstub, verify original behavior returns |
| AC-06 | `unmock_command` restores single command | Unmock, verify original command works |
| AC-07 | `unstub_function` restores single function | Unstub, verify original function works |
| AC-08 | `unmock_all` restores all mocks and stubs | Create multiple, unmock_all, verify all restored |
| AC-09 | Attempting to mock builtin returns error | Mock "cd", verify exit code 1 and error message |
| AC-10 | Double-mocking same command returns error | Mock twice, verify error on second call |

### 12.2 Isolation Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| IC-01 | Mocks don't leak between tests | Mock in test 1, verify not present in test 2 |
| IC-02 | Stubs don't leak between tests | Stub in test 1, verify original in test 2 |
| IC-03 | Failed test still gets cleanup | Test with mock fails assertion, next test clean |
| IC-04 | unmock_all called even if test crashes | Exit test early, verify cleanup happened |

### 12.3 Integration Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| IG-01 | Works with existing assertions | Use assert_equals with mock output |
| IG-02 | Works with TAP output mode | Run tests with `--tap`, mocks work |
| IG-03 | Works with verbose mode | Run tests with `--verbose`, mocks work |
| IG-04 | Works with watch mode | Change file, mocks work on re-run |
| IG-05 | Works with HTML reports | Generate report, test with mocks appears |

### 12.4 Error Handling Criteria

| ID | Criterion | Verification |
|----|-----------|--------------|
| EH-01 | Empty command name returns clear error | Verify message: "command name required" |
| EH-02 | Empty implementation returns clear error | Verify message: "implementation required" |
| EH-03 | Builtin mock returns clear error | Verify message: "cannot mock shell builtin" |
| EH-04 | Unmock non-mocked returns error | Verify message: "is not mocked" |
| EH-05 | Unstub non-stubbed returns error | Verify message: "is not stubbed" |

---

## Appendix A: Shell Builtins Reference

### Builtins That Cannot Be Mocked

```
cd        - Change directory (modifies shell state)
export    - Set environment variable (shell keyword)
source    - Execute file in current shell (shell keyword)
.         - Alias for source
exit      - Terminate shell (cannot intercept)
eval      - Execute arguments as command (shell keyword)
exec      - Replace shell process (cannot intercept)
return    - Return from function (shell keyword)
set       - Set shell options (shell keyword)
unset     - Unset variable/function (shell keyword)
readonly  - Make variable readonly (shell keyword)
declare   - Declare variable (shell keyword)
local     - Declare local variable (shell keyword)
trap      - Set signal handler (modifies shell state)
builtin   - Execute builtin (meta-command)
command   - Execute command (meta-command)
type      - Display command type (builtin)
hash      - Remember command path (builtin)
read      - Read input (builtin with special behavior)
echo      - Output text (can be mocked on some systems)
printf    - Format output (builtin)
test      - Evaluate expression (builtin)
[         - Alias for test (builtin)
]         - Part of [ syntax
```

### Why Builtins Can't Be Mocked

1. **Shell Keywords**: `export`, `source`, etc. are parsed before function lookup
2. **State Modifiers**: `cd`, `trap` modify shell state that can't be undone
3. **Process Control**: `exit`, `exec` affect the shell process itself
4. **Meta-Commands**: `builtin`, `command` bypass function lookup intentionally

---

## Appendix B: Examples Repository

### Example: Testing a Deployment Script

```bash
# deploy.sh
deploy() {
    echo "Checking branch..."
    branch=$(git rev-parse --abbrev-ref HEAD)

    if [[ "$branch" != "main" ]]; then
        echo "Error: Can only deploy from main branch" >&2
        return 1
    fi

    echo "Running tests..."
    npm test || return 1

    echo "Building..."
    npm run build || return 1

    echo "Deploying..."
    aws s3 sync ./dist s3://my-bucket/ || return 1

    echo "Notifying team..."
    curl -X POST https://hooks.slack.com/... \
        -d '{"text":"Deployment complete"}'

    echo "Done!"
}

# deploy_test.sh
test_deploy_succeeds_on_main_branch() {
    mock_command "git" 'echo "main"'
    mock_command "npm" 'return 0'
    mock_command "aws" 'return 0'
    mock_command "curl" 'return 0'

    source deploy.sh
    deploy

    assert_equals 0 $?
}

test_deploy_fails_on_feature_branch() {
    mock_command "git" 'echo "feature/test"'

    source deploy.sh
    output=$(deploy 2>&1)
    exit_code=$?

    assert_equals 1 "$exit_code"
    assert_output_contains "only deploy from main" "echo '$output'"
}

test_deploy_fails_if_tests_fail() {
    mock_command "git" 'echo "main"'
    mock_command "npm" '
        if [[ "$1" == "test" ]]; then
            echo "Tests failed" >&2
            return 1
        fi
        return 0
    '

    source deploy.sh
    deploy

    assert_equals 1 $?
}
```

---

*Document Version: 1.0*
*Last Updated: 2025-01-04*
*Status: Specification Complete - Ready for Implementation*
